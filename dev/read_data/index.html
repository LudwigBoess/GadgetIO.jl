<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reading Data · GadgetIO.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GadgetIO.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../install/">Install</a></li><li class="is-active"><a class="tocitem" href>Reading Data</a><ul class="internal"><li><a class="tocitem" href="#Reading-the-header"><span>Reading the header</span></a></li><li><a class="tocitem" href="#Reading-a-snapshot"><span>Reading a snapshot</span></a></li><li><a class="tocitem" href="#Large-Simulations"><span>Large Simulations</span></a></li><li class="toplevel"><a class="tocitem" href="#Read-Subfind-Data"><span>Read Subfind Data</span></a></li><li><a class="tocitem" href="#Reading-the-header-2"><span>Reading the header</span></a></li><li><a class="tocitem" href="#Reading-the-subfind-files"><span>Reading the subfind files</span></a></li><li><a class="tocitem" href="#Filtered-readin"><span>Filtered readin</span></a></li></ul></li><li><a class="tocitem" href="../write_data/">Writing Data</a></li><li><a class="tocitem" href="../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reading Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reading Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LudwigBoess/GadgetIO.jl/blob/master/docs/src/read_data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Read-Snapshot-Data"><a class="docs-heading-anchor" href="#Read-Snapshot-Data">Read Snapshot Data</a><a id="Read-Snapshot-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Snapshot-Data" title="Permalink"></a></h1><h2 id="Reading-the-header"><a class="docs-heading-anchor" href="#Reading-the-header">Reading the header</a><a id="Reading-the-header-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-the-header" title="Permalink"></a></h2><p>Reading the header block of the simulation can be done by using:</p><pre><code class="language-julia"> h = read_header(filename::String)</code></pre><p>Where <code>h</code> is the returned <a href="@ref"><code>Header</code></a> object:</p><pre><code class="language-julia">mutable struct Header
    npart::Vector{Int32}                # an array of particle numbers per type in this snapshot
    massarr::Vector{Float64}            # an array of particle masses per type in this snapshot - if zero: MASS block present
    time::Float64                       # time / scale factor of the simulation
    z::Float64                          # redshift of the simulation
    flag_sfr::Int32                     # 1 if simulation was run with star formation, else 0
    flag_feedback::Int32                # 1 if simulation was run with stellar feedback, else 0
    nall::Vector{UInt32}                # total number of particles in the simulation
    flag_cooling::Int32                 # 1 if simulation was run with cooling, else 0
    num_files::Int32                    # number of snapshots over which the simulation is distributed
    boxsize::Float64                    # total size of the simulation box
    omega_0::Float64                    # Omega matter
    omega_l::Float64                    # Omega dark enery
    h0::Float64                         # little h
    flag_stellarage::Int32              # 1 if simulation was run with stellar age, else 0
    flag_metals::Int32                  # 1 if simulation was run with metals, else 0
    npartTotalHighWord::Vector{UInt32}  # weird
    flag_entropy_instead_u::Int32       # 1 if snapshot U field contains entropy instead of internal energy, else 0
    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0
    flag_ic_info::Int32                 # 1 if the IC file contains an INFO block   
    lpt_scalingfactor::Float32          # (almost) never used
    fill::Vector{Int32}                 # the HEAD block needs to be filled with zeros to have a size of 256 bytes
end</code></pre><p>This is equivalent to:</p><pre><code class="language-julia"> h = head_to_obj(filename::String)</code></pre><p>If you want to read the header information into a dictionary you can use:</p><pre><code class="language-julia"> h = head_to_dict(filename::String)</code></pre><h2 id="Reading-a-snapshot"><a class="docs-heading-anchor" href="#Reading-a-snapshot">Reading a snapshot</a><a id="Reading-a-snapshot-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-snapshot" title="Permalink"></a></h2><h3 id="Full-snapshot"><a class="docs-heading-anchor" href="#Full-snapshot">Full snapshot</a><a id="Full-snapshot-1"></a><a class="docs-heading-anchor-permalink" href="#Full-snapshot" title="Permalink"></a></h3><p>If you want to read a simulation snapshot into memory with GadgetIO.jl, it&#39;s as easy as this:</p><pre><code class="language-julia">    data = read_snap(filename)</code></pre><p>This will return a dictionary with the header information in <code>data[&quot;Header&quot;]</code> and the blocks sorted by particle type.</p><p>As an example, this is how you would access the positions of the gas particles:</p><pre><code class="language-julia">    data[&quot;Parttype0&quot;][&quot;POS&quot;]</code></pre><h3 id="Specific-blocks"><a class="docs-heading-anchor" href="#Specific-blocks">Specific blocks</a><a id="Specific-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-blocks" title="Permalink"></a></h3><p>Reading specific blocks only works with Format 2 at the moment.</p><p>If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function with a specified blockname and particle type like so:</p><pre><code class="language-julia">    pos = read_snap(filename, &quot;POS&quot;, 0)</code></pre><p>This will return an array of the datatype of your simulation, usually <code>Float32</code>.</p><p>If the snapshot has no info block this will fail unfortunately.</p><p>You can still read the specific block by supplying a hand-constructed <a href="@ref"><code>Info_Line</code></a> object:</p><pre><code class="language-julia">mutable struct Info_Line
    block_name::String              # name of the data block, e.g. &quot;POS&quot;
    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double
    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3
    is_present::Vector{Int32}       # array of flags for which particle type this block is present,
                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]
                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]
end</code></pre><p>and passing that to the function <a href="../api/#GadgetIO.read_block_by_name-Tuple{String,String}"><code>read_block_by_name</code></a>:</p><pre><code class="language-julia">    pos = read_block_by_name(filename, &quot;POS&quot;, info=pos_info, parttype=0)</code></pre><p>where <code>pos_info</code> is an <a href="@ref"><code>Info_Line</code></a> object.</p><p><a href="../api/#GadgetIO.read_snap"><code>read_snap</code></a> is used mainly as a wrapper function to call <a href="../api/#GadgetIO.read_block_by_name-Tuple{String,String}"><code>read_block_by_name</code></a>, in case you were wondering about the function name change.</p><p>I will collect some example <code>Info_Line</code> objects in a later release to be able to read some common blocks even without an info block.</p><h3 id="Getting-snapshot-infos"><a class="docs-heading-anchor" href="#Getting-snapshot-infos">Getting snapshot infos</a><a id="Getting-snapshot-infos-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-snapshot-infos" title="Permalink"></a></h3><p>If you have a Format 2 snapshot and just want to know what blocks the snapshot contains you can use the function</p><pre><code class="language-julia">    print_blocks(filename)</code></pre><p>to get an output of all block names.</p><p>If your simulation contains an INFO block you can read the info lines into <a href="@ref"><code>Info_Line</code></a> object like so:</p><pre><code class="language-julia">    info = read_info(filename, verbose=true)</code></pre><p>This will return an Array of <a href="@ref"><code>Info_Line</code></a> objects. The optional keyword <code>verbose</code> additionally gives the same functionality as <a href="../api/#GadgetIO.print_blocks-Tuple{String}"><code>print_blocks</code></a> and prints the names to the console.</p><h2 id="Large-Simulations"><a class="docs-heading-anchor" href="#Large-Simulations">Large Simulations</a><a id="Large-Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Large-Simulations" title="Permalink"></a></h2><p>For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.</p><p>To get all particles within a subvolume of the simulation you can use the functions <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String,Array{String,1},Any,Any}"><code>read_particles_in_box</code></a> or <a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String,Array{String,1},Any,Any}"><code>read_particles_in_volume</code></a>.</p><p><a href="../api/#GadgetIO.read_particles_in_box-Tuple{String,Array{String,1},Any,Any}"><code>read_particles_in_box</code></a> takes a box defined by a lower-left corner and an upper-right corner, constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary.</p><pre><code class="language-julia">function read_particles_in_box(filename::String, blocks::Vector{String},
                               corner_lowerleft,
                               corner_upperright;
                               parttype::Int=0,
                               verbose::Bool=true)

            (...)

end</code></pre><p>You can define an array of blocks you want to read, these will be read in parallel with simple multi-threading.</p><p><a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String,Array{String,1},Any,Any}"><code>read_particles_in_volume</code></a> is a simple wrapper around <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String,Array{String,1},Any,Any}"><code>read_particles_in_box</code></a>, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.</p><pre><code class="language-julia">function read_particles_in_volume(filename::String, blocks::Vector{String},
                                  center_pos::Vector{AbstractFloat},
                                  radius::AbstractFloat;
                                  parttype::Int=0,
                                  verbose::Bool=true)

            (...)
end</code></pre><p>In both functions <code>parttype</code> defines the particle type to be read, as in the previous read functions and <code>verbose</code> gives console output.</p><h3 id="Filename"><a class="docs-heading-anchor" href="#Filename">Filename</a><a id="Filename-1"></a><a class="docs-heading-anchor-permalink" href="#Filename" title="Permalink"></a></h3><p>With the snapshots being distributed over multiple filenames you need to be careful with that keyword. In this case filename refers to the base-name. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the filename is</p><pre><code class="language-julia">filename = &quot;path/to/your/snapshot/directories/snapdir_140/snap_140&quot;</code></pre><p>GadgetIO will then automatically loop through the sub-snapshots which end in &quot;.0&quot;, &quot;.1&quot;, ... , &quot;.N&quot;.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.</p><p>Assuming <code>pos_halo</code> is the position of the center of mass of the halo and <code>r_vir</code> is its virial radius you read the data with</p><pre><code class="language-julia">blocks = [&quot;POS&quot;, &quot;VEL&quot;, &quot;MASS&quot;, &quot;RHO&quot;, &quot;HSML&quot;]

data   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,
                                  parttype=0,
                                  verbose=true)</code></pre><p>This will return a dictionary with the blocks as keys and containing the arrays for the particles.</p><pre><code class="language-julia">data[&quot;POS&quot;]  # array of positions
data[&quot;RHO&quot;]  # array of densities
(...)</code></pre><h3 id="Upcoming"><a class="docs-heading-anchor" href="#Upcoming">Upcoming</a><a id="Upcoming-1"></a><a class="docs-heading-anchor-permalink" href="#Upcoming" title="Permalink"></a></h3><p>One of the next steps will be to finish the reading function for particles in a specific halo. Since this is a bit of a pain I postponed this to when I will actually need it.</p><h1 id="Read-Subfind-Data"><a class="docs-heading-anchor" href="#Read-Subfind-Data">Read Subfind Data</a><a id="Read-Subfind-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Subfind-Data" title="Permalink"></a></h1><h2 id="Reading-the-header-2"><a class="docs-heading-anchor" href="#Reading-the-header-2">Reading the header</a><a class="docs-heading-anchor-permalink" href="#Reading-the-header-2" title="Permalink"></a></h2><p>Similarly to the normal snapshot you can read the header of the subfind output into a <a href="@ref"><code>SubfindHeader</code></a> object</p><pre><code class="language-julia">struct SubfindHeader
    nhalos::Int32                       # number of halos in the output file
    nsubhalos::Int32                    # number of subhalos in the output file
    nfof::Int32                         # number of particles in the FoF
    ngroups::Int32                      # number of large groups in the output file
    time::Float64                       # time / scale factor of the simulation
    z::Float64                          # redshift of the simulation
    tothalos::UInt32                    # total number of halos over all output files
    totsubhalos::UInt32                 # total number of subhalos over all output files
    totfof::UInt32                      # total number of particles in the FoF
    totgroups::UInt32                   # total number of large groups over all output files
    num_colors::Int32                   # number of colors
    boxsize::Float64                    # total size of the simulation box
    omega_0::Float64                    # Omega matter
    omega_l::Float64                    # Omega dark enery
    h0::Float64                         # little h
    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0
    flag_ic_info::Int32
end</code></pre><p>using</p><pre><code class="language-julia">h = read_subfind_header(filename::String)</code></pre><h2 id="Reading-the-subfind-files"><a class="docs-heading-anchor" href="#Reading-the-subfind-files">Reading the subfind files</a><a id="Reading-the-subfind-files-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-the-subfind-files" title="Permalink"></a></h2><p>If you compiled Gadget with <code>WRITE_SUB_IN_SNAP_FORMAT</code> you can read the subfind output like you would a normal snapshot, with any of the above methods. For convenience you can also use a helper function provided by GadgetIO. Since each of the blocks is only relevant for either halos, subhalos, Fof or large groups you don&#39;t need to define a particly type, aka halo type in this case.</p><p>So in order to read the virial radius of the halos in a file you can simply use</p><pre><code class="language-julia">R_vir = read_subfind(filename, &quot;RVIR&quot;)</code></pre><h2 id="Filtered-readin"><a class="docs-heading-anchor" href="#Filtered-readin">Filtered readin</a><a id="Filtered-readin-1"></a><a class="docs-heading-anchor-permalink" href="#Filtered-readin" title="Permalink"></a></h2><p>If you want to read specific halos from the subfind output you can use the function</p><pre><code class="language-julia">filter_subfind(filebase::String, blockname::String, filter_function::Function, nfiles::Integer=1)</code></pre><p>This will return an array of <a href="@ref">SubfindID</a>s </p><pre><code class="language-julia">struct SubfindID
    file::Int64
    id::Int64
end</code></pre><p>You can use this to read specific files with <a href="@ref"><code>read_subfind</code></a> and select the array entry via the <code>id</code> field.</p><p>The <code>filter_function</code> argument takes any function that takes one input argument and returns <code>true</code> if the requirement is fulfilled, or <code>false</code> if not.</p><p>So to find e.g. all halos with a virial mass largert than <span>$10^{15} M_\odot$</span> you can use</p><pre><code class="language-julia">find_mass_gt_1e15(M) = ( (M &gt; 1.e15) ? true : false )

filtered_subfind = filter_subfind(filebase, &quot;MVIR&quot;, find_mass_gt_1e15)</code></pre><p>This will search all subfind files in the directory and check if they fulfill the filter. Since halos in subfind files are sorted by mass you can also supply a number of files to search with the argument <code>nfiles</code>. That way, if you are looking for a very massive halo you can constrian the reading and filtering to only the first <code>N</code> files to save time.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Install</a><a class="docs-footer-nextpage" href="../write_data/">Writing Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 16 August 2020 12:15">Sunday 16 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
