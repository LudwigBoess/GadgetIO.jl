<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reading Snapshots · GadgetIO.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GadgetIO.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../install/">Install</a></li><li><a class="tocitem" href="../file_infos/">File Infos</a></li><li class="is-active"><a class="tocitem" href>Reading Snapshots</a><ul class="internal"><li><a class="tocitem" href="#Filename"><span>Filename</span></a></li><li><a class="tocitem" href="#Reading-a-snapshot"><span>Reading a snapshot</span></a></li><li><a class="tocitem" href="#Read-Subvolumes"><span>Read Subvolumes</span></a></li><li><a class="tocitem" href="#Read-distributed-snapshotfiles"><span>Read distributed snapshotfiles</span></a></li><li><a class="tocitem" href="#Reading-particles-by-referenced-ID"><span>Reading particles by referenced ID</span></a></li></ul></li><li><a class="tocitem" href="../read_subfind/">Reading Subfind</a></li><li><a class="tocitem" href="../write_data/">Writing Data</a></li><li><a class="tocitem" href="../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reading Snapshots</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reading Snapshots</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LudwigBoess/GadgetIO.jl/blob/master/docs/src/read_snapshots.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Read-Snapshot-Data"><a class="docs-heading-anchor" href="#Read-Snapshot-Data">Read Snapshot Data</a><a id="Read-Snapshot-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Snapshot-Data" title="Permalink"></a></h1><hr/><p><strong>NOTE</strong></p><p>From v0.4 and up snapshots are read in proper column-major order, as it should be for Julia. This means that position data for particle <code>i</code> neads be accessed as:</p><pre><code class="language-none">x = pos[1,i]
y = pos[2,i]
z = pos[3,i]</code></pre><hr/><p><code>GadgetIO.jl</code> is specialized to read <code>Gadget</code> snapshots of <code>Format 2</code>. The structure of a <code>Format 2</code> snapshot is as follows:</p><pre><code class="language-none">8              # size of the blockname block (Int32)
BLOCKNAME      # Blockname (4*Char)
8+SIZE_BLOCK   # number of bytes to skip if block should not be read
8              # end of blockname block

SIZE_BLOCK     # size of the current block in bytes
{...}          # content of the block ordered by particle type
SIZE_BLOCK     # end of the current block</code></pre><p>which repeats for every block.</p><h2 id="Filename"><a class="docs-heading-anchor" href="#Filename">Filename</a><a id="Filename-1"></a><a class="docs-heading-anchor-permalink" href="#Filename" title="Permalink"></a></h2><p>Before we get started, a short bit for clarification: In what follows we need to distinguish between <code>filename</code> and <code>filebase</code>. For small simulations the data is written to a single file. In that case you can simply supply an absolute, or relative path to the one snapshot file as <code>filename</code>.</p><p>For larger simulations the data may be distributed over multiple files, which again may be in individual snapshot directories. With the snapshots being distributed over multiple files you need to supply the base-name <code>filebase</code>. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the <code>filebase</code> is</p><pre><code class="language-julia">filebase = &quot;path/to/your/snapshot/directories/snapdir_140/snap_140&quot;</code></pre><p>In the relevant functions <code>GadgetIO.jl</code> will then automatically loop through the sub-snapshots which end in &quot;.0&quot;, &quot;.1&quot;, ... , &quot;.N&quot;.</p><h2 id="Reading-a-snapshot"><a class="docs-heading-anchor" href="#Reading-a-snapshot">Reading a snapshot</a><a id="Reading-a-snapshot-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-snapshot" title="Permalink"></a></h2><p>There are multiple ways to read the data in the snapshot</p><h3 id="Full-snapshot"><a class="docs-heading-anchor" href="#Full-snapshot">Full snapshot</a><a id="Full-snapshot-1"></a><a class="docs-heading-anchor-permalink" href="#Full-snapshot" title="Permalink"></a></h3><p>If you want to read a simulation snapshot into memory with <code>GadgetIO.jl</code>, it&#39;s as easy as this:</p><pre><code class="language-julia">    data = read_snap(filename)</code></pre><p>This will return a dictionary with the header information in <code>data[&quot;Header&quot;]</code> and the blocks sorted by particle type.</p><p>As an example, this is how you would access the positions of the gas particles:</p><pre><code class="language-julia">    data[&quot;Parttype0&quot;][&quot;POS&quot;]</code></pre><h3 id="Specific-blocks"><a class="docs-heading-anchor" href="#Specific-blocks">Specific blocks</a><a id="Specific-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-blocks" title="Permalink"></a></h3><p>If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function with a specified blockname and particle type like so:</p><pre><code class="language-julia">    pos = read_snap(filename, &quot;POS&quot;, 0)</code></pre><p>This will return an array of the datatype of your simulation, usually <code>Float32</code>.</p><p>If the snapshot has no info block this will fail unfortunately.</p><p>You can still read the specific block by supplying a hand-constructed <a href="../api/#GadgetIO.InfoLine"><code>InfoLine</code></a> object:</p><pre><code class="language-julia">struct InfoLine
    block_name::String              # name of the data block, e.g. &quot;POS&quot;
    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double
    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3
    is_present::Vector{Int32}       # array of flags for which particle type this block is present,
                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]
                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]
end</code></pre><p>and passing that to the function <a href="../api/#GadgetIO.read_block-Tuple{String, String}"><code>read_block</code></a>:</p><pre><code class="language-julia">pos = read_block(filename, &quot;POS&quot;, info=pos_info, parttype=0)</code></pre><p>where <code>pos_info</code> is an <a href="../api/#GadgetIO.InfoLine"><code>InfoLine</code></a> object.</p><p><a href="../api/#GadgetIO.read_snap"><code>read_snap</code></a> is used mainly as a wrapper function to call <a href="../api/#GadgetIO.read_block-Tuple{String, String}"><code>read_block</code></a>, in case you were wondering about the function name change.</p><p>I will collect some example <code>InfoLine</code> objects in a later release to be able to read some common blocks even without an <code>INFO</code> block.</p><p>Since <code>v0.5</code> <a href="../api/#GadgetIO.read_snap"><code>read_snap</code></a> and <a href="../api/#GadgetIO.read_block-Tuple{String, String}"><code>read_block</code></a> also work if you pass them a <code>file_base</code>.</p><h2 id="Read-Subvolumes"><a class="docs-heading-anchor" href="#Read-Subvolumes">Read Subvolumes</a><a id="Read-Subvolumes-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Subvolumes" title="Permalink"></a></h2><p>If you only want to read a subvolume of the whole simulation you can do this in two ways. To get all particles within a subvolume of the simulation you can use the functions <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var&quot;#s624&quot;, N} where {var&quot;#s624&quot;&lt;:Real, N}, Array{var&quot;#s623&quot;, N} where {var&quot;#s623&quot;&lt;:Real, N}}"><code>read_particles_in_box</code></a> or <a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}"><code>read_particles_in_volume</code></a>.</p><p><a href="../api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var&quot;#s624&quot;, N} where {var&quot;#s624&quot;&lt;:Real, N}, Array{var&quot;#s623&quot;, N} where {var&quot;#s623&quot;&lt;:Real, N}}"><code>read_particles_in_box</code></a> takes a box defined by a lower-left corner and an upper-right corner and reads all requested blocks and particles in that volume.</p><pre><code class="language-julia">function read_particles_in_box( filename::String, blocks::Vector{String},
                                corner_lowerleft,
                                corner_upperright;
                                parttype::Int=0,
                                verbose::Bool=true,
                                use_keys::Bool=true )

            (...)

end</code></pre><p>You can define an array of blocks you want to read, these will be read in parallel with simple multi-threading.</p><p><a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}"><code>read_particles_in_volume</code></a> is a simple wrapper around <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var&quot;#s624&quot;, N} where {var&quot;#s624&quot;&lt;:Real, N}, Array{var&quot;#s623&quot;, N} where {var&quot;#s623&quot;&lt;:Real, N}}"><code>read_particles_in_box</code></a>, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.</p><pre><code class="language-julia">function read_particles_in_volume( filename::String, blocks::Vector{String},
                                   center_pos::Vector{AbstractFloat},
                                   radius::AbstractFloat;
                                   parttype::Int=0,
                                   verbose::Bool=true,
                                   use_keys::Bool=true )

            (...)
end</code></pre><p>For reading particles in more complex geometries you can use <a href="../api/#GadgetIO.read_particles_in_geometry-Tuple{String, String, AbstractGadgetGeometry}"><code>read_particles_in_geometry</code></a>.</p><pre><code class="language-julia">read_particles_in_geometry( filename::String, blocks::Vector{String},
                            geometry::AbstractGadgetGeometry;
                            parttype::Integer=0, verbose::Bool=true,
                            use_keys::Bool=true)</code></pre><p>You can use built-in geometries like <a href="../api/#GadgetIO.GadgetCube"><code>GadgetCube</code></a>, <a href="../api/#GadgetIO.GadgetSphere"><code>GadgetSphere</code></a> and <a href="../api/#GadgetIO.GadgetCylinder"><code>GadgetCylinder</code></a>.</p><p>If you want to extend the functionality you can define your own geometry as</p><pre><code class="language-julia">struct YourGeometry{T} &lt;: AbstractGadgetGeometry
    prop1::Vector{T}
    prop2::Vector{T}
    prop3::T
    (...)
end</code></pre><p>and define the functions <a href="../api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCube}"><code>get_geometry_box_corners</code></a> and <a href="../api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCube, Matrix{T}}} where T"><code>get_geometry_mask</code></a>. <a href="../api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCube}"><code>get_geometry_box_corners</code></a> has to return a <code>Tuple</code> of two vectors which define the lower left and upper right corner of a box that contains the <code>geometry</code>. <a href="../api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCube, Matrix{T}}} where T"><code>get_geometry_mask</code></a> has to return an array of indices for which <code>pos</code> is contained in the <code>geometry</code>.</p><p>In all functions <code>parttype</code> defines the particle type to be read, as in the previous read functions and <code>verbose</code> gives console output. There are also multiple dispatch versions of all functions available that only take a single <code>block</code> as input and return an array with the values instead of a dictionary.</p><h3 id="Peano-Hilbert-key-based-reading"><a class="docs-heading-anchor" href="#Peano-Hilbert-key-based-reading">Peano-Hilbert key based reading</a><a id="Peano-Hilbert-key-based-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Peano-Hilbert-key-based-reading" title="Permalink"></a></h3><p>For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.</p><p>If you call <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var&quot;#s624&quot;, N} where {var&quot;#s624&quot;&lt;:Real, N}, Array{var&quot;#s623&quot;, N} where {var&quot;#s623&quot;&lt;:Real, N}}"><code>read_particles_in_box</code></a> or <a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}"><code>read_particles_in_volume</code></a> with the keyword argument <code>use_keys=true</code> (which is the default case) it constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary. This is considerably faster than the brute-force attempt.</p><h3 id="Brute-Force-Reading"><a class="docs-heading-anchor" href="#Brute-Force-Reading">Brute-Force Reading</a><a id="Brute-Force-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Brute-Force-Reading" title="Permalink"></a></h3><p>If you call <a href="../api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var&quot;#s624&quot;, N} where {var&quot;#s624&quot;&lt;:Real, N}, Array{var&quot;#s623&quot;, N} where {var&quot;#s623&quot;&lt;:Real, N}}"><code>read_particles_in_box</code></a> or <a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}"><code>read_particles_in_volume</code></a> with the keyword argument <code>use_keys=false</code> it reads all particles over all distributed files which are contained in the requested subvolume. This takes quite a lot longer than the key based reading, but sometimes it&#39;s the only option.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.</p><p>Assuming <code>pos_halo</code> is the position of the center of mass of the halo and <code>r_vir</code> is its virial radius you read the data with</p><pre><code class="language-julia">blocks = [&quot;POS&quot;, &quot;VEL&quot;, &quot;MASS&quot;, &quot;RHO&quot;, &quot;HSML&quot;]

data   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,
                                  parttype=0,
                                  verbose=true)</code></pre><p>This will return a dictionary with the blocks as keys and containing the arrays for the particles.</p><pre><code class="language-julia">data[&quot;POS&quot;]  # array of positions
data[&quot;RHO&quot;]  # array of densities
(...)</code></pre><h2 id="Read-distributed-snapshotfiles"><a class="docs-heading-anchor" href="#Read-distributed-snapshotfiles">Read distributed snapshotfiles</a><a id="Read-distributed-snapshotfiles-1"></a><a class="docs-heading-anchor-permalink" href="#Read-distributed-snapshotfiles" title="Permalink"></a></h2><p>If you want to read multiple blocks in a simulation whose snapshots have been distributed over a number of sub-snapshots you can use <a href="../api/#GadgetIO.read_blocks_over_all_files-Tuple{String, Array{String, N} where N}"><code>read_blocks_over_all_files</code></a>.</p><pre><code class="language-julia">read_blocks_over_all_files( snap_base::String, blocks::Array{String};
                            filter_function::Union{Function, Nothing}=nothing, 
                            read_positions::Union{Dict, Nothing}=nothing, 
                            parttype::Integer=0, verbose::Bool=true )</code></pre><p>This will read the specified <code>blocks</code> for all particles that pass the <code>filter_function</code>. This can be useful if you don&#39;t know where the region you are interested in is located and don&#39;t have enough memory to read in all particles. Alternatively you can also provide a <code>Dict</code> with <code>read_positions</code> as described in <a href="#Read-positions">Read positions</a>.</p><h3 id="Filter-functions"><a class="docs-heading-anchor" href="#Filter-functions">Filter functions</a><a id="Filter-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-functions" title="Permalink"></a></h3><p>The <code>filter_function</code> can be any function that takes a <code>String</code> input and returns an <code>Array</code> of <code>Integer</code>s, or <code>CartesianCoordinates</code>. For example, if you want to filter all particles with a Mach number larger than 1:</p><pre><code class="language-julia">function mach_gt_1(snap_file)
    mach = read_snap(snap_file, &quot;MACH&quot;, 0)
    sel  = findall( mach .&gt; 1.0 )
    return sel
end</code></pre><p>Or if you want to trick the function into reading all particles after all:</p><pre><code class="language-julia">function pass_all(snap_file)
    h = read_header(snap_file)
    return collect(1:h.npart[1])
end</code></pre><p>As an example, to read positions, velocity and ID of all shocked particles from distributed snapshots use</p><pre><code class="language-julia">blocks = [&quot;POS&quot;, &quot;VEL&quot;, &quot;ID&quot;]
data = read_blocks_over_all_files(snap_base, blocks, filter_function=mach_gt_1, parttype=0)</code></pre><p>Just as a reminder from above you can read single blocks into an array by using <a href="../api/#GadgetIO.read_snap"><code>read_snap</code></a> and <a href="../api/#GadgetIO.read_block-Tuple{String, String}"><code>read_block</code></a>:</p><pre><code class="language-julia">pos = read_block(snap_base, &quot;POS&quot;, parttype=0)</code></pre><p>This requiers <code>GadgetIO.jl</code> v0.5 though.</p><h3 id="Read-positions"><a class="docs-heading-anchor" href="#Read-positions">Read positions</a><a id="Read-positions-1"></a><a class="docs-heading-anchor-permalink" href="#Read-positions" title="Permalink"></a></h3><p>To avoid having to filter all files each time you want to read a snapshot you can also split the steps. You can first filter the particles to find the positions of the particles within the data blocks with <a href="../api/#GadgetIO.find_read_positions-Tuple{Array{var&quot;#s7&quot;, N} where {var&quot;#s7&quot;&lt;:Integer, N}, String, Array{String, N} where N, Integer, Array{var&quot;#s6&quot;, N} where {var&quot;#s6&quot;&lt;:Integer, N}, Array{InfoLine, N} where N, Bool}"><code>find_read_positions</code></a></p><pre><code class="language-julia">read_positions = find_read_positions(snap_base, filter_function)</code></pre><p>and then save the result as a binary file with <a href="../api/#GadgetIO.save_read_positions-Tuple{String, Any}"><code>save_read_positions</code></a></p><pre><code class="language-julia">save_read_positions(save_file, read_positions)</code></pre><p>where <code>save_file</code> is the filename you specified for storage.</p><p>This also works with an <a href="@ref"><code>AbstractGadgetGeometry</code></a> by calling <a href="../api/#GadgetIO.find_read_positions-Tuple{Array{var&quot;#s7&quot;, N} where {var&quot;#s7&quot;&lt;:Integer, N}, String, Array{String, N} where N, Integer, Array{var&quot;#s6&quot;, N} where {var&quot;#s6&quot;&lt;:Integer, N}, Array{InfoLine, N} where N, Bool}"><code>find_read_positions</code></a> with</p><pre><code class="language-julia">find_read_positions( snap_base::String, geometry::AbstractGadgetGeometry;
                     parttype::Integer=0,
                     verbose::Bool=true )</code></pre><p>To re-use the <code>read_positions</code> you can load them from file using <a href="../api/#GadgetIO.load_read_positions-Tuple{String}"><code>load_read_positions</code></a></p><pre><code class="language-julia">read_positions = load_read_positions(save_file)</code></pre><p>This can then be used to read any number of blocks with</p><pre><code class="language-julia">blocks = [&quot;POS&quot;, &quot;VEL&quot;, &quot;ID&quot;]
data = read_blocks_over_all_files(snap_base, blocks, read_positions=read_positions, parttype=0)</code></pre><h2 id="Reading-particles-by-referenced-ID"><a class="docs-heading-anchor" href="#Reading-particles-by-referenced-ID">Reading particles by referenced ID</a><a id="Reading-particles-by-referenced-ID-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-particles-by-referenced-ID" title="Permalink"></a></h2><p>If you want to select specific particles to read from an array of <code>IDs</code> you can do this with <a href="../api/#GadgetIO.read_particles_by_id-Tuple{String, Array{var&quot;#s620&quot;, N} where {var&quot;#s620&quot;&lt;:Integer, N}, Array{String, N} where N}"><code>read_particles_by_id</code></a>:</p><pre><code class="language-julia">read_particles_by_id(snap_base::String, selected_ids::Array{&lt;:Integer}, 
                     blocks::Array{String}; 
                     parttype::Integer=0, verbose::Bool=true,
                     pos0::Union{Array{&lt;:Real},Nothing}=nothing,
                     r0::Real=0.0,
                     use_keys::Bool=true )</code></pre><p><code>snap_base</code> defines the target snapshot, or the snapshot basename, <code>selected_ids</code> contains the list of IDs of the particles you want to read and <code>blocks</code> containes the blocknames of the blocks you want to read. If the simulation is too large to read the whole snapshot into memory you can give values for <code>pos0</code> and <code>r0</code> to read only a specific region with <a href="../api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}"><code>read_particles_in_volume</code></a>. See <a href="#Read-Subvolumes">Read Subvolumes</a> for details on this.</p><p>This will return a dictionary with all requested blocks.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../file_infos/">« File Infos</a><a class="docs-footer-nextpage" href="../read_subfind/">Reading Subfind »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 6 May 2021 15:53">Thursday 6 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
