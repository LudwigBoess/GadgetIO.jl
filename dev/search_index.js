var documenterSearchIndex = {"docs":
[{"location":"read_subfind/#Read-Subfind-Data","page":"Reading Subfind","title":"Read Subfind Data","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Gadget contains an on-the-fly halo-finder as described in Springel et al (2001) or Dolag et al (2009). This sections provides an overview of the functions you can use to work with this output. Please note that you need to compile Gadget with WRITE_SUB_IN_SNAP_FORMAT to use this functionality.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Please note that since subfind files are equivalent to snapshot files you can use the same functions as in if you Read Snapshot Data.","category":"page"},{"location":"read_subfind/#Reading-the-header","page":"Reading Subfind","title":"Reading the header","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"As in the normal snapshot the subfind output also contains a HEAD block with useful information. You can read the header of the subfind output into a GadgetIO.SubfindHeader object by using","category":"page"},{"location":"read_subfind/#GadgetIO.read_subfind_header","page":"Reading Subfind","title":"GadgetIO.read_subfind_header","text":"read_subfind_header(filename::String)\n\nReads the header of a subfind file or file base (without .0, .1, etc.) into a SubfindHeader struct.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"The subfind header contains the fields ","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Name Meaning\nnhalos::Int32 number of halos in the output file\nnsubhalos::Int32 number of subhalos in the output file\nnfof::Int32 number of particles in the FoF\nngroups::Int32 number of large groups in the output file\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\ntothalos::UInt32 total number of halos over all output files\ntotsubhalos::UInt32 total number of subhalos over all output files\ntotfof::UInt32 total number of particles in the FoF\ntotgroups::UInt32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of files over which subfind data is distributed\nboxsize::Float64 total size of the simulation box\nomega_0::Float64 Omega matter\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0","category":"page"},{"location":"read_subfind/#Reading-the-subfind-files","page":"Reading Subfind","title":"Reading the subfind files","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"For convenience you can use a helper function provided by GadgetIO.jl to read the block of the subfind output. Since each of the blocks is only relevant for either halos, subhalos, FoF or large groups you don't need to define a particly type, aka halo type in this case.","category":"page"},{"location":"read_subfind/#GadgetIO.read_subfind","page":"Reading Subfind","title":"GadgetIO.read_subfind","text":"read_subfind(filename::String, blockname::String)\n\nExample\n\nTo read e.g. the virial radius of halos use\n\nR_vir = read_subfind(filename, \"RVIR\")\n\n\n\n\n\nread_subfind(filename::String, blockname::String, ids::AbstractVector{<:Integer}; return_haloid::Bool=false)\n\nReads the block at the given subfind indices (ids, 0-indexed).\n\nIf return_haloid is true, returns a tuple of the block array and the corresponding HaloIDs.\n\nExample\n\n# Read the virial masses of the first four halos in subfind:\nmvir = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3])\n\n# or:\nmvir, haloids = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3]; return_haloid=true)\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/#Filtered-read-in","page":"Reading Subfind","title":"Filtered read-in","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to read specific halos from the subfind output you can use the function","category":"page"},{"location":"read_subfind/#GadgetIO.filter_subfind","page":"Reading Subfind","title":"GadgetIO.filter_subfind","text":"filter_subfind(sub_base::String, filter_function::Function, files=nothing)\n\nFilters all entries in a subfind file that fulfill the 'filter_funcion' requirements and returns a Vector of HaloIDs.\n\nExamples\n\n# load packages\nusing GadgetIO, GadgetUnits\n\n# define filter function\nfunction find_mvir_gt_1e15(filename) \n    h = read_header(filename)\n    GU = GadgetPhysical(h) # unit conversion\n\n    # read Mvir and convert to solar masses \n    M = read_subfind(filename, \"MVIR\") .* GU.m_msun\n\n    return findall(M .> 1.0e15)\nend\n\n# basename of subfind output (without .*)\nsub_base = /path/to/groups_000/sub_000\n\n# get relevant halos from first 10 files\nhalo_ids = filter_subfind(sub_base, find_mvir_gt_1e15, 0:9)\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"This will return an array of HaloIDs which contain the fields","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Name Meaning\nfile::Int64 number of the subfile that contains the halo, e.g. \"sub_000.2\"\nid::Int64 position in the block","category":"page"},{"location":"read_subfind/#Saving/Loading-HaloIDs","page":"Reading Subfind","title":"Saving/Loading HaloIDs","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you do complex filtering and want to save the result you can use","category":"page"},{"location":"read_subfind/#GadgetIO.save_halo_ids","page":"Reading Subfind","title":"GadgetIO.save_halo_ids","text":"save_halo_ids(filename::String, halo_ids::Vector{HaloID})\n\nWrites a Vector of HaloIDs to a files.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"and load them the next time with ","category":"page"},{"location":"read_subfind/#GadgetIO.load_halo_ids","page":"Reading Subfind","title":"GadgetIO.load_halo_ids","text":"save_halo_ids(filename::String)\n\nLoads a Vector of HaloIDs from a file.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to use HaloIDs with read_blocks_filtered you can convert convert the HaloIDs to read_positions by using","category":"page"},{"location":"read_subfind/#GadgetIO.halo_ids_to_read_positions","page":"Reading Subfind","title":"GadgetIO.halo_ids_to_read_positions","text":"halo_ids_to_read_positions(halo_ids::Vector{HaloID})\n\nConvert a Vector of HaloIDs to a dictionary of read_positions.  To be used with read_blocks_filtered.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/#Reading-halo-properties","page":"Reading Subfind","title":"Reading halo properties","text":"","category":"section"},{"location":"read_subfind/#GadgetIO.read_halo_prop","page":"Reading Subfind","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blockname::AbstractString, haloid::HaloID; verbose::Bool=true)\n\nGet halo property from block blockname by halo id. Returns an array or scalar depending on the block type.\n\n\n\n\n\nread_halo_prop(sub_base, blockname::AbstractString, i_global::Integer; verbose::Bool=true)\n\nGet halo property from block blockname by global halo index i_global (zero-based index).\n\n\n\n\n\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloids::AbstractVector{HaloID}; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for an Array of HaloIDs. Please note that this only works if all blocks are of the same halo type.     Returns a dictionary with all requested blocks.\n\n\n\n\n\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloid::HaloID; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for a HaloID. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\nread_halo_prop(sub_base, block::AbstractString, haloids::AbstractVector{HaloID}; verbose::Bool=true)\n\nGet halo properties defined by the block for an Array of HaloIDs. Returns an array with the requested block.\n\n\n\n\n\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::AbstractVector{<:Integer}; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for an Array of global indices. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::Integer; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for a global index. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\nread_halo_prop(sub_base, block::AbstractString, i_global::AbstractVector{<:Integer}; verbose::Bool=true)\n\nGet halo properties defined by the block for an Array of global indices. Returns an array with the requested block.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/#By-HaloID","page":"Reading Subfind","title":"By HaloID","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"You can read any property of the halo that passed the filter_function (see Filtered read-in) by using read_halo_prop with an individual HaloID","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"read_halo_prop(sub_base, blockname::AbstractString, haloid::HaloID; verbose::Bool=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"So if you want to read e.g. the virial radius for the first halo that passed your filter_function","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir = read_halo_prop(filebase, \"MVIR\", filtered_subfind[1])","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"HaloIDs can also be obtained in a vector of all halos by setting the keyword parameter return_haloid to true:","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir, haloids = read_subfind(filename, \"MVIR\"; return_haloid=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"You can also read single or multiple blocks at once for single or multiple HaloIDs.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"# multiple blocks, multiple HaloIDs -> returns Dict with blocks as keys\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloids::AbstractVector{HaloID}; verbose::Bool=true)\n# multiple blocks, single HaloID -> returns Dict with blocks as keys\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloid::HaloID; verbose::Bool=true)\n# single block, multiple HaloIDs -> returns vector of block\nread_halo_prop(sub_base, block::AbstractString, haloids::AbstractVector{HaloID}; verbose::Bool=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Please note: These functions will return the result ordered by increasing HaloIDs, which may not be the order of the Vector{HaloID} you put in! ","category":"page"},{"location":"read_subfind/#By-global-halo-index","page":"Reading Subfind","title":"By global halo index","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you have a global index of a halo from subfind (0-indexed, increasing over all subfiles of the subfind outputs), you can also read a halo's properties from subfind. To read a halo property from such a global halo index and convert it to a HaloID you can use ","category":"page"},{"location":"read_subfind/#GadgetIO.read_halo_prop_and_id","page":"Reading Subfind","title":"GadgetIO.read_halo_prop_and_id","text":"read_halo_prop_and_id(sub_base, blockname::AbstractString, i_global::Integer; verbose::Bool=true)\n\nGet halo property and HaloID from block blockname by global halo index i_global (zero-based index). nfiles should generally be set to h.num_files, obtained from read_header. When nfiles is not passed, it is read automatically from the header.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"To only obtain the property use","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"read_halo_prop(sub_base, blockname::AbstractString, i_global::Integer; verbose::Bool=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"So for example if you have the global halo id i_global and want to read the corresponding virial mass you can use one of the two following lines (note that it is faster to read properties via the HaloID since only a single file has to be read for that):","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir, halo_id = read_halo_prop_and_id(filebase, \"MVIR\", i_global)\nmvir = read_halo_prop(filebase, \"MVIR\", i_global)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"To read the properties of multiple halos for which the halo indices are available, use one of the following two lines (to read the virial masses of the first four halos in subfind):","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3])\nmvir = read_subfind(filebase, \"MVIR\", 0:3)\nmvir, haloids = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3]; return_haloid=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"The results are returned in the order of the given indices.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Again you can also read single or multiple blocks at once for single or multiple indices.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"# multiple blocks, multiple indices -> returns Dict with blocks as keys\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::AbstractVector{<:Integer}; verbose::Bool=true)\n# multiple blocks, single index -> returns Dict with blocks as keys\nread_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::Integer; verbose::Bool=true)\n# single block, multiple indices -> returns vector of block\nread_halo_prop(sub_base, block::AbstractString, i_global::AbstractVector{<:Integer}; verbose::Bool=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Please note: These functions will return the result ordered by increasing indices, which may not be the order of the Vector{i_global} you put in! ","category":"page"},{"location":"read_subfind/#Converting-global-halo-indices-to-HaloIDs","page":"Reading Subfind","title":"Converting global halo indices to HaloIDs","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to convert global halo indices to HaloIDs use","category":"page"},{"location":"read_subfind/#GadgetIO.global_idxs_to_halo_id","page":"Reading Subfind","title":"GadgetIO.global_idxs_to_halo_id","text":"global_idxs_to_halo_id(sub_base::String, idxs::Vector{<:Integer}; \n                        parttype::Integer=0)\n\nConverts global halo indices to HaloIDs.\n\n\n\n\n\nglobal_idxs_to_halo_id(sub_base::String, offset::Integer, n_to_read::Integer;\n                        parttype::Integer=0)\n\nConverts a given number of indices defined by offset and n_to_read to HaloIDs.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"You can then save the HaloIDs with Saving/Loading HaloIDs or convert them to read_positions with halo_ids_to_read_positions.","category":"page"},{"location":"read_subfind/#Reading-particles-in-a-halo","page":"Reading Subfind","title":"Reading particles in a halo","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to read all particles associated with a FoF halo you can do this with the function ","category":"page"},{"location":"read_subfind/#GadgetIO.read_particles_in_halo","page":"Reading Subfind","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo(snap_base::String, blocks::Array{String},\n                            sub_base::String, halo::HaloID; \n                            radius::Union{Real,Nothing}=nothing,\n                            rad_scale::Real=1.0, halo_type::Integer=1,\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns a Dict with each of the blocks as entries.\n\n\n\n\n\nread_particles_in_halo( snap_base::String, block::String,\n                        sub_base::String, halo::HaloID; \n                        kwargs...)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns an Array with the requested block.\n\n\n\n\n\n","category":"function"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"This reads all blocks defined in blocks for the halo into a dictionary. snap_base and sub_base should point to the snap and subfind filebase as in other functions, or the files if you only have one file. The HaloID point to the selected halo. halo_type should be set to 1 for halos and 2 for subhalos.  If you didn't get all the particles you were looking for it might be that the search radius for the read-in was too small. rad_scale defines the multiplication factor for the search radius. For halos the default search radius is r_200 and for subhalos it's the half-mass radius.","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/#GadgetIO.block_present","page":"API reference","title":"GadgetIO.block_present","text":"block_present(filename::String, blockname::String, blocks::Vector{String}=[\"\"])\n\nChecks if a given block is present in the snapshot file, or in the supplied blocks Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.filter_cube-Tuple{String, Array{<:Real}, Array{<:Real}}","page":"API reference","title":"GadgetIO.filter_cube","text":"filter_cube(snap_file::String, corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real}, \n                      parttype::Integer)\n\nReads positions from snap_file and returns the indices of particles contained in a box defined by corner_lowerleft and corner_upperright.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_cylinder-Tuple{String, Array{<:Real}, Array{<:Real}, Real}","page":"API reference","title":"GadgetIO.filter_cylinder","text":"filter_cylinder(filename::String, pt1::Array{<:Real}, pt2::Array{<:Real}, r::Real)\n\nReads the positions contained in a file and returns the indices of particles contained in a cylinder defined by the endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_ids-Tuple{String, Vector{<:Integer}, Integer}","page":"API reference","title":"GadgetIO.filter_ids","text":"filter_ids(snap_file::String, selected_ids::Vector{<:Integer})\n\nReads IDs from snap_file and returns the indices of particles matching the selected_ids\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_subfind","page":"API reference","title":"GadgetIO.filter_subfind","text":"filter_subfind(sub_base::String, filter_function::Function, files=nothing)\n\nFilters all entries in a subfind file that fulfill the 'filter_funcion' requirements and returns a Vector of HaloIDs.\n\nExamples\n\n# load packages\nusing GadgetIO, GadgetUnits\n\n# define filter function\nfunction find_mvir_gt_1e15(filename) \n    h = read_header(filename)\n    GU = GadgetPhysical(h) # unit conversion\n\n    # read Mvir and convert to solar masses \n    M = read_subfind(filename, \"MVIR\") .* GU.m_msun\n\n    return findall(M .> 1.0e15)\nend\n\n# basename of subfind output (without .*)\nsub_base = /path/to/groups_000/sub_000\n\n# get relevant halos from first 10 files\nhalo_ids = filter_subfind(sub_base, find_mvir_gt_1e15, 0:9)\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_most_massive_halo","page":"API reference","title":"GadgetIO.find_most_massive_halo","text":"find_most_massive_halo(filebase::String [, nfiles::Int=1])\n\nReads the selected file and its subfiles and returns position, virial radius and a HaloID object that contains the subfile which contains the most massive halo and the position in the block.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_read_positions-Tuple{String, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions( snap_base::String, geometry::AbstractGadgetGeometry;\n                     parttype::Integer=0,\n                     verbose::Bool=true )\n\nFinds the number of particles and their storage location in a snapshot directory that are contained in the space defined by geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_read_positions-Tuple{String, Function}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions( snap_base::String, filter_function::Function)\n\nFinds the number of particles and their storage location in a snapshot directory that pass the filter_function.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list-Tuple{Vector{<:Integer}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.get_index_list","text":"get_index_list(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nFinds the indices at which list_to_check contains elements from list_to_find. If both either of the lists are not sorted it uses a Set lookup, otherwise it uses a Vector forward-search.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_total_particles-Tuple{Integer, Integer}","page":"API reference","title":"GadgetIO.get_total_particles","text":"get_total_particles(h::AbstractGadgetHeader, parttype::Integer)\n\nCalculates to total number of particles present in the simulation. Accounts for integer overflow.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_total_particles-Tuple{SnapshotHeader, Integer}","page":"API reference","title":"GadgetIO.get_total_particles","text":"get_total_particles(h::AbstractGadgetHeader, parttype::Integer)\n\nCalculates to total number of particles present in the simulation. Accounts for integer overflow.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.global_idxs_to_halo_id-Tuple{String, AbstractVector{<:Integer}}","page":"API reference","title":"GadgetIO.global_idxs_to_halo_id","text":"global_idxs_to_halo_id(sub_base::String, idxs::Vector{<:Integer}; \n                        parttype::Integer=0)\n\nConverts global halo indices to HaloIDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.global_idxs_to_halo_id-Tuple{String, Integer, Integer}","page":"API reference","title":"GadgetIO.global_idxs_to_halo_id","text":"global_idxs_to_halo_id(sub_base::String, offset::Integer, n_to_read::Integer;\n                        parttype::Integer=0)\n\nConverts a given number of indices defined by offset and n_to_read to HaloIDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.halo_ids_to_read_positions-Tuple{Vector{HaloID}}","page":"API reference","title":"GadgetIO.halo_ids_to_read_positions","text":"halo_ids_to_read_positions(halo_ids::Vector{HaloID})\n\nConvert a Vector of HaloIDs to a dictionary of read_positions.  To be used with read_blocks_filtered.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_dict-Tuple{String}","page":"API reference","title":"GadgetIO.head_to_dict","text":"head_to_dict(filename::String)\n\nReturns the header of a snapshot as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_struct-Tuple{Any}","page":"API reference","title":"GadgetIO.head_to_struct","text":"head_to_struct(filename::String)\n\nReturns the header of a snapshot as a SnapshotHeader object.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.load_halo_ids-Tuple{String}","page":"API reference","title":"GadgetIO.load_halo_ids","text":"save_halo_ids(filename::String)\n\nLoads a Vector of HaloIDs from a file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.load_read_positions-Tuple{String}","page":"API reference","title":"GadgetIO.load_read_positions","text":"load_read_positions(save_file::String)\n\nLoads the relevant read-in positions from a binary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.parse_balance-Tuple{String}","page":"API reference","title":"GadgetIO.parse_balance","text":"parse_balance(filename)\n\nReads the balance.txt log file and returns a tuple of Arrays of (step_number, timing, active).\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.print_blocks-Tuple{String}","page":"API reference","title":"GadgetIO.print_blocks","text":"print_blocks(filename::String; verbose::Bool=true)\n\nReads the block names of blocks in a snapshot and returns them in an array. Outputs them to console if verbose=true\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.print_performance-Tuple{String}","page":"API reference","title":"GadgetIO.print_performance","text":"print_performance(filename)\n\nBasic info on performance from balance.txt file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block-Tuple{String, Union{Integer, String}}","page":"API reference","title":"GadgetIO.read_block","text":"read_block(filename::String, block_id::Union{String, Integer};\n            parttype::Integer=0,\n            block_position::Integer=-1,\n            info::Union{Nothing,InfoLine}=nothing,\n            h::Union{Nothing,SnapshotHeader}=nothing,\n            offset=0, n_to_read=-1)\n\nReads a block in a snapshot with block_id as a given name or position in the file. Defaults to reading gas particles. Block Names are case sensitive.\n\nKeyword Arguments\n\nparttype: Which particle type to read (0-indexed)\n0: Gas (default)\n1: Dark Matter\n2: Boundary\n3: Bulge\n4: Stars \n5: Black Holes\n-1: All particle types\nblock_position: Position of the block in the data file [bytes]. Can be used to speed up IO.\ninfo: InfoLine for the given block. Can be used to speed up IO, or if no INFO block is present.\nh: SnapshotHeader for given file. Can be used to speed up IO.\noffset: Adds an offset to start reading the block at a later point. Can be used for sub-IO.\nn_to_read: How many particles to read. Can be used for sub-IO.\n\nExamples (Format 2)\n\nIn case an INFO block is present:\n\ngas_pos = read_block(filename, \"POS\", parttype=0)\n\nIf not you need to supply your own InfoLine\n\npos_info = InfoLine(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\ngas_pos = read_block(filename, \"POS\", info=pos_info, parttype=0)\n\n# Examples (Format 1)\nIn case you want to read the default blocks:\n\njulia gaspos = readblock(filename, 1, parttype=0)\n\nIf not you need to supply your own `InfoLine`\n\njulia posinfo = InfoLine(\"\", Float32, 1, [1, 1, 1, 1, 1, 1]) gaspos = readblock(filename, 1, info=posinfo, parttype=0) ```\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_blocks_filtered-Tuple{String, Array{String}}","page":"API reference","title":"GadgetIO.read_blocks_filtered","text":"read_blocks_filtered( snap_base::String, blocks::Array{String};\n                            filter_function::Union{Function, Nothing}=nothing, \n                            read_positions::Union{Dict, Nothing}=nothing, \n                            parttype::Integer=0, verbose::Bool=true )\n\nReads the specified blocks from all distributed files where particles pass the filter_function, or are given by a Dict of read_positions. For read_positions please see find_read_positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractString, AbstractVector{<:Integer}}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, block::AbstractString, i_global::AbstractVector{<:Integer}; verbose::Bool=true)\n\nGet halo properties defined by the block for an Array of global indices. Returns an array with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractString, AbstractVector{HaloID}}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, block::AbstractString, haloids::AbstractVector{HaloID}; verbose::Bool=true)\n\nGet halo properties defined by the block for an Array of HaloIDs. Returns an array with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractString, HaloID}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blockname::AbstractString, haloid::HaloID; verbose::Bool=true)\n\nGet halo property from block blockname by halo id. Returns an array or scalar depending on the block type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractString, Integer}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blockname::AbstractString, i_global::Integer; verbose::Bool=true)\n\nGet halo property from block blockname by global halo index i_global (zero-based index).\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractVector{<:AbstractString}, AbstractVector{<:Integer}}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::AbstractVector{<:Integer}; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for an Array of global indices. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractVector{<:AbstractString}, AbstractVector{HaloID}}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloids::AbstractVector{HaloID}; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for an Array of HaloIDs. Please note that this only works if all blocks are of the same halo type.     Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractVector{<:AbstractString}, HaloID}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, haloid::HaloID; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for a HaloID. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{Any, AbstractVector{<:AbstractString}, Integer}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(sub_base, blocks::AbstractVector{<:AbstractString}, i_global::Integer; verbose::Bool=true)\n\nGet halo properties defined by an Array of blocks for a global index. Please note that this only works if all blocks are of the same halo type. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop_and_id-Tuple{Any, AbstractString, Integer}","page":"API reference","title":"GadgetIO.read_halo_prop_and_id","text":"read_halo_prop_and_id(sub_base, blockname::AbstractString, i_global::Integer; verbose::Bool=true)\n\nGet halo property and HaloID from block blockname by global halo index i_global (zero-based index). nfiles should generally be set to h.num_files, obtained from read_header. When nfiles is not passed, it is read automatically from the header.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_header","text":"read_header(filename::String)\n\nReads the header of a snapshot file or file base (without .0, .1, etc.) and returns a SnapshotHeader object.\n\nSee also: head_to_struct\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_ids_in_halo-Tuple{String, HaloID}","page":"API reference","title":"GadgetIO.read_ids_in_halo","text":"read_ids_in_halo( sub_base::String, halo::HaloID; \n                  halo_type::Integer=1, verbose::Bool=true)\n\nReads the IDs of all particles contained in a halo.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info-Tuple{String}","page":"API reference","title":"GadgetIO.read_info","text":"read_info(filename; verbose::Bool=false)\n\nReads the info block of a snapshot and returns the information in an array of InfoLine types. If verbose=true the blocknames are also printed to console.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String, Array{<:Integer}, Array{String}}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns all requested blocks as entries in a Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String, Array{<:Integer}, String}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     block::String; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns the requested block as an Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{<:Real}, Array{<:Real}}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, block::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nLike read_particles_in_box but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String, Vector{String}, Array{<:Real}, Array{<:Real}}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                    corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                    parttype::Integer=0, verbose::Bool=true,\n                    use_keys::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type. Returns a dictionary with all requested blocks. If use_keys=true it uses Peano-Hilbert keys to constrain the read-in, otherwise it uses a brute-force read-in with a filter function. Peano-Hilbert key based read-in is significantly faster.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_geometry-Tuple{String, String, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.read_particles_in_geometry","text":"read_particles_in_geometry( filename::String, block::String,\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_geometry-Tuple{String, Vector{String}, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.read_particles_in_geometry","text":"read_particles_in_geometry( filename::String, blocks::Vector{String},\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with all requested blocks. If shift_across_box_border is true, the particles are moved beyond the borders of a periodic box, if false, the periodicity of the box is still accounted for, but the particles' positions are not shifted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String, Array{String}, String, HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo(snap_base::String, blocks::Array{String},\n                            sub_base::String, halo::HaloID; \n                            radius::Union{Real,Nothing}=nothing,\n                            rad_scale::Real=1.0, halo_type::Integer=1,\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns a Dict with each of the blocks as entries.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String, String, String, HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo( snap_base::String, block::String,\n                        sub_base::String, halo::HaloID; \n                        kwargs...)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns an Array with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, block::String,\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_volume but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_volume\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String, Vector{String}, Array{<:Real}, Real}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box encapsulating a volume defined by center position and radius for a given particle type. Returns a dictionary with all requested blocks.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_snap","page":"API reference","title":"GadgetIO.read_snap","text":"read_snap(filename::String [, blockname::String=\"\", parttype::Integer=-1] )\n\nWrapper function to read snapshot in various ways: filename only: returns the entire snapshot as a dictionary. blockname: Returns only that block. If parttype specified only for that particle type.\n\nExamples\n\njulia> gas_pos = read_snap(filename, \"POS\", 0)\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.read_subfind-Tuple{String, String, AbstractVector{<:Integer}}","page":"API reference","title":"GadgetIO.read_subfind","text":"read_subfind(filename::String, blockname::String, ids::AbstractVector{<:Integer}; return_haloid::Bool=false)\n\nReads the block at the given subfind indices (ids, 0-indexed).\n\nIf return_haloid is true, returns a tuple of the block array and the corresponding HaloIDs.\n\nExample\n\n# Read the virial masses of the first four halos in subfind:\nmvir = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3])\n\n# or:\nmvir, haloids = read_subfind(filebase, \"MVIR\", [0, 1, 2, 3]; return_haloid=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subfind-Tuple{String, String}","page":"API reference","title":"GadgetIO.read_subfind","text":"read_subfind(filename::String, blockname::String)\n\nExample\n\nTo read e.g. the virial radius of halos use\n\nR_vir = read_subfind(filename, \"RVIR\")\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subfind_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_subfind_header","text":"read_subfind_header(filename::String)\n\nReads the header of a subfind file or file base (without .0, .1, etc.) into a SubfindHeader struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.save_halo_ids-Tuple{String, Vector{HaloID}}","page":"API reference","title":"GadgetIO.save_halo_ids","text":"save_halo_ids(filename::String, halo_ids::Vector{HaloID})\n\nWrites a Vector of HaloIDs to a files.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.save_read_positions-Tuple{String, Dict}","page":"API reference","title":"GadgetIO.save_read_positions","text":"save_read_positions(save_file::String, read_positions::Dict)\n\nSaves the relevant read-in positions to a binary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.snap_to_dict-Tuple{String}","page":"API reference","title":"GadgetIO.snap_to_dict","text":"snap_to_dict(filename::String)\n\nReads whole snapshot into memory and returns a dictionary sorted by particle type and block names. Be cautious with large snapshots!\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.write_block","page":"API reference","title":"GadgetIO.write_block","text":"write_block(f::IOStream, data,\n            blockname::String=\"\";\n            snap_format::Integer=2)\n\nWrite data to a block to an opened file f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_header-Tuple{IOStream, SnapshotHeader}","page":"API reference","title":"GadgetIO.write_header","text":"write_header(f::IOStream, h::SnapshotHeader; snap_format::Integer=2)\n\nWrites the header block to an opened file f.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.write_info_block-Tuple{IOStream, Vector{InfoLine}}","page":"API reference","title":"GadgetIO.write_info_block","text":"write_info_block(f::IOStream, info::Vector{InfoLine}; snap_format::Integer=2)\n\nWrites the info block to an opened file f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/#GadgetIO.AbstractGadgetHeader","page":"API reference","title":"GadgetIO.AbstractGadgetHeader","text":"AbstractGadgetHeader\n\nAbstract type to unify snapshot and subfind headers.\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetCube","page":"API reference","title":"GadgetIO.GadgetCube","text":"struct GadgetCube{T} <: AbstractGadgetGeometry\n    corner_lower_left::Vector{T}\n    corner_upper_right::Vector{T}\nend\n\nDefines a cube by corner_lower_left and corner_upper_right.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetCube-Union{Tuple{T}, Tuple{Vector{T}, T}} where T","page":"API reference","title":"GadgetIO.GadgetCube","text":"GadgetCube(center::Vector{T}, side_length::T) where T\n\nDefine a GadgetCube by its center and side length. \n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.GadgetCylinder","page":"API reference","title":"GadgetIO.GadgetCylinder","text":"struct GadgetCylinder{T} <: AbstractGadgetGeometry\n    pos_start::Vector{T}\n    pos_end::Vector{T}\n    radius::T\nend\n\nDefines a cylinder by two end points pos_start and pos_start as well as a radius.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetShell","page":"API reference","title":"GadgetIO.GadgetShell","text":"struct GadgetShell{T} <: AbstractGadgetGeometry\n    center::Vector{T}\n    radius::T\n    width::T\nend\n\nDefines a shell by center, radius and width. Radius is defined to the middle of the shell thickness.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetSphere","page":"API reference","title":"GadgetIO.GadgetSphere","text":"struct GadgetSphere{T} <: AbstractGadgetGeometry\n    center::Vector{T}\n    radius::T\nend\n\nDefines a sphere by center and radius.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.HaloID","page":"API reference","title":"GadgetIO.HaloID","text":"struct HaloID\n    file::Int64\n    id::Int64\nend\n\nStores the subfile that contains the halo in file and the position in the block in id.\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.InfoLine","page":"API reference","title":"GadgetIO.InfoLine","text":"struct InfoLine([  block_name=\"\", data_type=Float32, n_dim=Int32(0),\n                is_present=zeros(Int32, 6) ])\n\nContains the data of a single entry in the INFO block of a Gadget snapshot.\n\nFields\n\nName Meaning\nblock_name::String name of the data block, e.g. \"POS\"\ndata_type::DataType datatype of the block, e.g. Float32 for single precision, Float64 for double\nn_dim::Int32 number of dimensions of the block, usually 1 or 3\nis_present::Vector{Int32} array of flags for which particle type this block is present,\n e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ],\n or gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.SnapshotHeader","page":"API reference","title":"GadgetIO.SnapshotHeader","text":"mutable struct SnapshotHeader <: AbstractGadgetHeader\n\nContains the data of the HEAD block of a Gadget snapshot.\n\nFields\n\nName Meaning\nnpart::Vector{Int32} an array of particle numbers per type in this snapshot\nmassarr::Vector{Float64} an array of particle masses per type in this snapshot - if zero: MASS block present\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\nflag_sfr::Int32 1 if simulation was run with star formation, else 0\nflag_feedback::Int32 1 if simulation was run with stellar feedback, else 0\nnall::Vector{UInt32} total number of particles in the simulation\nflag_cooling::Int32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of snapshots over which the simulation is distributed\nomega_0::Float64 Omega matter\nboxsize::Float64 total size of the simulation box\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_stellarage::Int32 1 if simulation was run with stellar age, else 0\nflag_metals::Int32 1 if simulation was run with metals, else 0\nnpartTotalHighWord::Vector{UInt32} If Npart > 1584^3 (>2^32) this contains a high bit: ntotal = npartTotalHighWord*2^32 + nall\nflag_entropy_instead_u::Int32 1 if snapshot U field contains entropy instead of internal energy, else 0\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\nlpt_scalingfactor::Float32 factor to use second order ic generation\nfill::Vector{Int32} the HEAD block needs to be filled with zeros to have a size of 256 bytes\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.SubfindHeader","page":"API reference","title":"GadgetIO.SubfindHeader","text":"struct SubfindHeader\n\nContains the data of the HEAD block in the subfind output\n\nFields\n\nName Meaning\nnhalos::Int32 number of halos in the output file\nnsubhalos::Int32 number of subhalos in the output file\nnfof::Int32 number of particles in the FoF\nngroups::Int32 number of large groups in the output file\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\ntothalos::UInt32 total number of halos over all output files\ntotsubhalos::UInt32 total number of subhalos over all output files\ntotfof::UInt32 total number of particles in the FoF\ntotgroups::UInt32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of files over which subfind data is distributed\nboxsize::Float64 total size of the simulation box\nomega_0::Float64 Omega matter\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/#GadgetIO.allocate_data_dict-Tuple{Array{String}, Integer, Array{InfoLine}, Bool}","page":"API reference","title":"GadgetIO.allocate_data_dict","text":"allocate_data_dict( blocks::Array{String}, N_to_read::Integer, \n                    snap_info::Array{InfoLine}, no_mass_block::Bool )\n\nHelper function to allocate the data Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_block_position-Tuple{String, Integer}","page":"API reference","title":"GadgetIO.check_block_position","text":"check_block_position(filename::String, blocknum::Integer)\n\nHelper function to find read positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_block_position-Tuple{String, String}","page":"API reference","title":"GadgetIO.check_block_position","text":"check_block_position(filename::String, blockname::String)\n\nHelper function to find read positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocks-Tuple{String, Array{String}, Integer}","page":"API reference","title":"GadgetIO.check_blocks","text":"check_blocks(snap_base::String, blocks::Array{String})\n\nCheck if all requested blocks are present.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocksize-Tuple{IOStream, Integer, Integer}","page":"API reference","title":"GadgetIO.check_blocksize","text":"check_blocksize(f::IOStream, position_before::Integer, blocksize_before::Integer)\n\nChecks for integer overflow in the size of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocksize_format1-Tuple{IOStream, Integer, Integer}","page":"API reference","title":"GadgetIO.check_blocksize_format1","text":"check_blocksize_format1(f::IOStream, position_before::Integer, blocksize_before::Integer)\n\nChecks for integer overflow in the size of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_in_cylinder-NTuple{4, Any}","page":"API reference","title":"GadgetIO.check_in_cylinder","text":"check_in_cylinder(x, pt1, pt2, r)\n\nChecks if a 3D point x is in a cylinder defined by its endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_info-Tuple{String, Integer}","page":"API reference","title":"GadgetIO.check_info","text":"check_info(filename::String, blocknum::Integer)\n\nHelper function to assign default InfoLine to the block number if none was given.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_info-Tuple{String, String}","page":"API reference","title":"GadgetIO.check_info","text":"check_info(filename::String, blockname::String)\n\nHelper function to read INFO block or construct InfoLine for MASS block, if no INFO block is present. Returns a single InfoLine struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_snapshot_format-Tuple{Any}","page":"API reference","title":"GadgetIO.check_snapshot_format","text":"check_block_format(filename)\n\nChecks which binary format the file is in.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_subfind_parttype_for_multiple_blocks-Tuple{Any, AbstractVector{<:AbstractString}}","page":"API reference","title":"GadgetIO.check_subfind_parttype_for_multiple_blocks","text":"check_subfind_parttype_for_multiple_blocks(sub_base, blocks::AbstractVector{<:AbstractString})\n\nChecks if all requested blocks are for the same halo type and returns the correct halo type if true.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.construct_matched_dict-Tuple{Dict{String, VecOrMat}, Vector{String}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.construct_matched_dict","text":"construct_matched_dict(data_in::Dict{String, Union{Vector{T}, Array{T,2}}}, \n                            blocks::Array{String,1}, matched::Array{<:Integer,1}) where T\n\nWrite all matching particles to a new dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.convert_header-Tuple{SnapshotHeader}","page":"API reference","title":"GadgetIO.convert_header","text":"convert_header(h::SnapshotHeader)\n\nConverts a SnapshotHeader to a SubfindHeader.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.convert_string_to_int8-Tuple{String}","page":"API reference","title":"GadgetIO.convert_string_to_int8","text":"convert_string_to_int8(name::String)\n\nConverts a string to an array of Int8 to write to file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_positions-Tuple{String, Array{<:Real}, Array{<:Real}, Integer}","page":"API reference","title":"GadgetIO.filter_positions","text":"filter_positions(snap_file::String, corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real}, \n                      parttype::Integer)\n\nReads positions from snap_file and returns the indices of particles contained in a box defined by corner_lowerleft and corner_upperright.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_sphere-Tuple{String, Array{<:Real}, Real}","page":"API reference","title":"GadgetIO.filter_sphere","text":"filter_sphere(filename::String, center::Array{<:Real}, r::Real; parttype::Integer=0)\n\nReads the positions contained in a file and returns the indices of particles contained in a cylinder defined by the endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_files_for_keys-Tuple{String, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.find_files_for_keys","text":"find_files_for_keys(filebase::String, nfiles::Integer, keylist::Vector{<:Integer})\n\nSelects the files in which the particles associated with the given Peano-Hilbert keys are stored.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions","text":"get_block_positions(filename::String; \n                    snap_format::Integer=2)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\nExample\n\n# Format 2 -> default\nblock_positions = get_block_positions(filename)\nblock_positions[\"POS\"]\n# Format 1\nblock_positions = get_block_positions(filename)\nblock_positions[1]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions_format1-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions_format1","text":"get_block_positions_format1(filename::String)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\nExample\n\nblock_positions = get_block_positions(filename)\nblock_positions[\"POS\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions_format2-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions_format2","text":"get_block_positions_format2(filename::String)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\nExample\n\nblock_positions = get_block_positions(filename)\nblock_positions[\"POS\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_datatype_name-Tuple{DataType, Int32}","page":"API reference","title":"GadgetIO.get_datatype_name","text":"function get_datatype_name(dt::DataType, dim::Integer)\n\nConvert the datatype into a string and then to a vector of 8bit integers to match name in Gadget.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_first_containing_file-Tuple{Any, Any}","page":"API reference","title":"GadgetIO.get_first_containing_file","text":"get_first_containing_file(snap_base, parttype)\n\nReturns the filename of the first subfile of sub_base that contains the given particle type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCube}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(cube::GadgetCube)\n\nReturns a Tuple with the lower left and upper right corner of a box which contains the cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCylinder}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(cylinder::GadgetCylinder)\n\nReturns a tuple with the lower left and upper right corner of a box which contains the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetShell}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(shell::GadgetShell)\n\nReturns a tuple with the lower left and upper right corner of a box which contains the shell.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetSphere}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(sphere::GadgetSphere)\n\nReturns a tuple with the lower left and upper right corner of a box which contains the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetCube}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(sphere::GadgetCube)\n\nReturns the center of cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetCylinder}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(cylinder::GadgetCylinder)\n\nReturns the center of cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetShell}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(shell::GadgetShell)\n\nReturns the center of shell.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetSphere}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(sphere::GadgetSphere)\n\nReturns the center of sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCube, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(cube::GadgetCube, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCylinder, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(cylinder::GadgetCylinder, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetShell, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(shell::GadgetShell, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the shell.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetSphere, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(sphere::GadgetSphere, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_bounds-Tuple{Vector{<:Integer}, Vector{<:Integer}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.get_index_bounds","text":"get_index_bounds(ids::Vector{<:Integer}, low_bounds::Vector{<:Integer}, high_bounds::Vector{<:Integer})\n\nReturns sorted Vector of indices i, for which low_bounds[i]  ids[j]  high_bounds[i] for any j. All parameters ids, low_bounds, and high_bounds have to already be sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_arr-Tuple{Vector{<:Integer}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.get_index_list_arr","text":"get_index_list_arr(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses forward-searching in sorted array. Both arrays have to be sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_dict-Tuple{Vector{<:Integer}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.get_index_list_dict","text":"get_index_list_dict(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses a Dict for lookup -> slower than the array search, but works on unsorted arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_set-Tuple{Vector{<:Integer}, Vector{<:Integer}}","page":"API reference","title":"GadgetIO.get_index_list_set","text":"get_index_list_set(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses a Set for lookup -> slower than the array search get_index_list_arr, but works on unsorted arrays like get_index_list_dict, just faster.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_info-Tuple{AbstractVector{InfoLine}, String}","page":"API reference","title":"GadgetIO.get_info","text":"get_info(info::AbstractVector{InfoLine}, blockname::String)\n\nHelper function to obtain a given InfoLine from a list or construct it for a MASS block, if no INFO block is present. Returns a single InfoLine struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_int8_blockname-Tuple{InfoLine}","page":"API reference","title":"GadgetIO.get_int8_blockname","text":"get_int8_blockname(info::InfoLine)\n\nPad the stored block name with spaces and convert to Array of Int8.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_int_pos-Tuple{Real, Real, Real, Integer}","page":"API reference","title":"GadgetIO.get_int_pos","text":"get_int_pos(pos::Real, domain_corner::Real, domain_fac::Real, bits::Integer)\n\nComputes the integer position along the PH line.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_keylist-Union{Tuple{T}, Tuple{GadgetIO.KeyHeader, Array{T}, Array{T}}} where T","page":"API reference","title":"GadgetIO.get_keylist","text":"get_keylist(h_key::KeyHeader, x0::Array{<:Real}, x1::Array{<:Real})\n\nGet all Peano-Hilbert keys for domain defined by the corner points x0 and x1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_pos_block_name-Tuple{Any}","page":"API reference","title":"GadgetIO.get_pos_block_name","text":"function get_pos_block_name(halo_type)\n\nReturns the position block name depending on the halo type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_rad_block_name-Tuple{Any, Any}","page":"API reference","title":"GadgetIO.get_rad_block_name","text":"function get_rad_block_name(sub_file, halo_type)\n\nReturns the radius block name depending on the halo type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_requested_info-Tuple{Array{InfoLine}, AbstractString}","page":"API reference","title":"GadgetIO.get_requested_info","text":"get_requested_info(snap_info::Array{InfoLine}, block::AbstractString)\n\nChecks if the InfoLine is present for the requested block, or if the MASS block is requested, but not in the INFO block. \n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.join_blocks-Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"API reference","title":"GadgetIO.join_blocks","text":"joinblocks(offsetkey, partperkey)\n\nJoins neighboring blocks to simplify read-in.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.peano_hilbert_key-NTuple{4, Integer}","page":"API reference","title":"GadgetIO.peano_hilbert_key","text":"peano_hilbert_key(bits::Integer, x::Integer, y::Integer, z::Integer)\n\nComputes a Peano-Hilbert key for an integer triplet (x,y,z) with x,y,z typically in the range between 0 and 2^bits-1. Values outside this range can occur when reading across the periodic box borders.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_all_parttypes-Tuple{String, Union{Integer, String}}","page":"API reference","title":"GadgetIO.read_all_parttypes","text":"read_all_parttypes( filename::String, block_id::String;\n                    block_position::Integer=-1,\n                    info::Union{Nothing,InfoLine}=nothing,\n                    h::Union{Nothing,SnapshotHeader}=nothing)\n\nReads the requested block for all particle types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block!","page":"API reference","title":"GadgetIO.read_block!","text":"read_block!(a::AbstractArray, f::IOStream,\n            offset::Integer,\n            nread::Integer, n_to_read::Integer;\n            parttype::Integer,\n            block_position::Integer,\n            info::InfoLine,\n            h::SnapshotHeader)\n\nRead part of a block from a given file stream into a pre-allocated array.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.read_block!-Tuple{AbstractArray, IOStream, Array{<:Integer}, Integer, Array{<:Integer}}","page":"API reference","title":"GadgetIO.read_block!","text":"read_block!(a::AbstractArray, f::IOStream,\n            offset::Array{<:Integer},\n            nread::Integer, n_to_read::Array{<:Integer};\n            parttype::Integer,\n            block_position::Integer,\n            info::InfoLine,\n            h::SnapshotHeader)\n\nRead part of a block from a given file stream into a pre-allocated array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_bockname-Tuple{IOStream}","page":"API reference","title":"GadgetIO.read_bockname","text":"read_bockname(f::IOStream)\n\nReads the name of the Format 2 block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info_line-Tuple{IOStream}","page":"API reference","title":"GadgetIO.read_info_line","text":"read_info_line(f::IOStream)\n\nHelper function to read the binary data into a InfoLine struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_key_block-Tuple{String, Vector{InfoLine}, Vector{String}, String, Integer}","page":"API reference","title":"GadgetIO.read_key_block","text":"read_key_block( filename_keyfile::String, key_info::Vector{InfoLine}, \n                fields::Vector{String}, key::String, parttype::Integer)\n\nReturns key block for different key. Valid values of key: KEY, NKEY, OKEY\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_key_index-Tuple{String}","page":"API reference","title":"GadgetIO.read_key_index","text":"read_key_index(file_key_index::String)\n\nReads the .key.index file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_keyheader-Tuple{String}","page":"API reference","title":"GadgetIO.read_keyheader","text":"read_keyheader(filename::String)\n\nReads the header of a .key file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box_peano-Tuple{String, Vector{String}, Array{<:Real}, Array{<:Real}}","page":"API reference","title":"GadgetIO.read_particles_in_box_peano","text":"read_particles_in_box_peano(filename::String, blocks::Vector{String},\n                            corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                            parttype::Integer=0, verbose::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type based on peano hilbert key reading. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_pids-Tuple{String, Signed, Signed}","page":"API reference","title":"GadgetIO.read_pids","text":"read_pids(sub_base::String, N_ids::Signed, offset::Signed)\n\nReads the PID block in the subfind output.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_positions_from_PH_keys-Tuple{String, Array{<:Real}, Array{<:Real}}","page":"API reference","title":"GadgetIO.read_positions_from_PH_keys","text":"read_positions_from_PH_keys(filebase::String,\n                            corner_lowerleft::Array{<:Real}, \n                            corner_upperright::Array{<:Real};\n                            parttype::Integer, verbose::Bool)\n\nFinds the Peano-Hilbert keys in a cube defined by corner_lowerleft and corner_upperright.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_positions_from_keys_files-Tuple{Vector{<:Integer}, String, Vector{<:Integer}, Vector{InfoLine}}","page":"API reference","title":"GadgetIO.read_positions_from_keys_files","text":"read_positions_from_PH_keys(files::Vector{<:Integer}, filebase::String, \n                            blocks::AbstractVector{String}, parttype::Integer,\n                            keylist::Vector{<:Integer}, key_info::Vector{InfoLine},\n                            verbose::Bool)\n\nHelper function to get positions and length of particle blocks in files.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_positions_to_halo_ids-Tuple{Any}","page":"API reference","title":"GadgetIO.read_positions_to_halo_ids","text":"read_positions_to_halo_ids(read_positions)\n\nConverts read_positions to a Vector of HaloIDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subfind_length-Tuple{String, String}","page":"API reference","title":"GadgetIO.read_subfind_length","text":"read_subfind_length(filename::String, blockname::String)\n\nGet number of entries for block blockname. Uses the header, so it is faster than reading the whole block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.reduce_read_positions-Tuple{Array{<:Integer}}","page":"API reference","title":"GadgetIO.reduce_read_positions","text":"reduce_read_positions(sel::Array{<:Integer})\n\nReduces the individual read positions by finding sub-ranges.  Returns an array of read indices and an array with the number of entries per index.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.select_file-Tuple{String, Integer}","page":"API reference","title":"GadgetIO.select_file","text":"select_file(filebase::String, filenum::Integer)\n\nChecks if the requested files exists and returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.shift_across_box_border-NTuple{4, Real}","page":"API reference","title":"GadgetIO.shift_across_box_border","text":"shift_across_box_border(x::Real, x_halo::Real, boxsize::Real, boxsize_half::Real)\n\nShift coordinate x across the box border if the zero coordinate x is on the other side.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.subfind_block_parttype","page":"API reference","title":"GadgetIO.subfind_block_parttype","text":"subfind_block_parttype(filename, blockname)\n\nGet the particle type for which a subfind block is relevant.\n\n\n\n\n\n","category":"function"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/#GadgetIO.KeyHeader","page":"API reference","title":"GadgetIO.KeyHeader","text":"struct KeyHeader\n\nHelper struct to store header information of .key files.\n\nFields\n\nName Meaning\nnkeys_file Number of keys in this .key file\ndomain_corners Corners of the domains defined by these keys\ndomain_fac Factor needed for reconstructung int positions\nbits Size of PH keys it bits\nnkeys_total Total number of keys in all files\nnkeys_total_highword Total number of keys in all files\n\n\n\n\n\n","category":"type"},{"location":"read_cpu_files/#Read-CPU-log-files","page":"Reading CPU files","title":"Read CPU log files","text":"","category":"section"},{"location":"read_cpu_files/","page":"Reading CPU files","title":"Reading CPU files","text":"Gadget writes a number of CPU log files. We provide some parsers to work with their output.","category":"page"},{"location":"read_cpu_files/#balance.txt","page":"Reading CPU files","title":"balance.txt","text":"","category":"section"},{"location":"read_cpu_files/","page":"Reading CPU files","title":"Reading CPU files","text":"The balance file contains information on the wallclock time of each timestep and how many particles are active during that step. You can get this information with","category":"page"},{"location":"read_cpu_files/#GadgetIO.parse_balance","page":"Reading CPU files","title":"GadgetIO.parse_balance","text":"parse_balance(filename)\n\nReads the balance.txt log file and returns a tuple of Arrays of (step_number, timing, active).\n\n\n\n\n\n","category":"function"},{"location":"read_cpu_files/","page":"Reading CPU files","title":"Reading CPU files","text":"This automatically skips over restarts and only outputs unique timesteps, i.e. if you start from a restartfile and Gadget has to re-do some of the timesteps, this function will only output the second iteration.","category":"page"},{"location":"file_infos/#File-information","page":"File Infos","title":"File information","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Since Gadget outputs in binary format it can be quite tedious to see what is actually contained in the file. For this GadgetIO provides a number of helper functions.","category":"page"},{"location":"file_infos/#Reading-the-header","page":"File Infos","title":"Reading the header","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"The header block (HEAD) contains a number of informations about the file, for example how many particles of which kind are contained in the file, the current time or redshift, the cosmological parameters and so on.","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"The most convenient way to deal with this data is to read the header block into a SnapshotHeader struct by using","category":"page"},{"location":"file_infos/#GadgetIO.read_header","page":"File Infos","title":"GadgetIO.read_header","text":"read_header(filename::String)\n\nReads the header of a snapshot file or file base (without .0, .1, etc.) and returns a SnapshotHeader object.\n\nSee also: head_to_struct\n\n\n\n\n\n","category":"function"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"the struct contains the following fields:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Name Meaning\nnpart::Vector{Int32} an array of particle numbers per type in this snapshot\nmassarr::Vector{Float64} an array of particle masses per type in this snapshot - if zero: MASS block present\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\nflag_sfr::Int32 1 if simulation was run with star formation, else 0\nflag_feedback::Int32 1 if simulation was run with stellar feedback, else 0\nnall::Vector{UInt32} total number of particles in the simulation\nflag_cooling::Int32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of snapshots over which the simulation is distributed\nomega_0::Float64 Omega matter\nboxsize::Float64 total size of the simulation box\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_stellarage::Int32 1 if simulation was run with stellar age, else 0\nflag_metals::Int32 1 if simulation was run with metals, else 0\nnpartTotalHighWord::Vector{UInt32} If Npart > 1584^3 (>2^32) this contains a high bit: ntotal = npartTotalHighWord*2^32 + nall\nflag_entropy_instead_u::Int32 1 if snapshot U field contains entropy instead of internal energy, else 0\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\nlpt_scalingfactor::Float32 factor to use second order ic generation\nfill::Vector{Int32} the HEAD block needs to be filled with zeros to have a size of 256 bytes","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"read_header is a wrapper around:","category":"page"},{"location":"file_infos/#GadgetIO.head_to_struct","page":"File Infos","title":"GadgetIO.head_to_struct","text":"head_to_struct(filename::String)\n\nReturns the header of a snapshot as a SnapshotHeader object.\n\n\n\n\n\n","category":"function"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you want to read the header information into a dictionary you can use:","category":"page"},{"location":"file_infos/#GadgetIO.head_to_dict","page":"File Infos","title":"GadgetIO.head_to_dict","text":"head_to_dict(filename::String)\n\nReturns the header of a snapshot as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"file_infos/#Getting-the-block-names","page":"File Infos","title":"Getting the block names","text":"","category":"section"},{"location":"file_infos/#GadgetIO.print_blocks","page":"File Infos","title":"GadgetIO.print_blocks","text":"print_blocks(filename::String; verbose::Bool=true)\n\nReads the block names of blocks in a snapshot and returns them in an array. Outputs them to console if verbose=true\n\n\n\n\n\n","category":"function"},{"location":"file_infos/#Checking-if-a-block-is-present","page":"File Infos","title":"Checking if a block is present","text":"","category":"section"},{"location":"file_infos/#GadgetIO.block_present","page":"File Infos","title":"GadgetIO.block_present","text":"block_present(filename::String, blockname::String, blocks::Vector{String}=[\"\"])\n\nChecks if a given block is present in the snapshot file, or in the supplied blocks Vector.\n\n\n\n\n\n","category":"function"},{"location":"file_infos/#Getting-the-block-positions-within-a-file","page":"File Infos","title":"Getting the block positions within a file","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you want to read in multiple blocks into individual variables you can speed the process up significantly by first getting the starting positions of the blocks with","category":"page"},{"location":"file_infos/#GadgetIO.get_block_positions","page":"File Infos","title":"GadgetIO.get_block_positions","text":"get_block_positions(filename::String; \n                    snap_format::Integer=2)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\nExample\n\n# Format 2 -> default\nblock_positions = get_block_positions(filename)\nblock_positions[\"POS\"]\n# Format 1\nblock_positions = get_block_positions(filename)\nblock_positions[1]\n\n\n\n\n\n","category":"function"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This returns a dictionary with the block names as keys and the starting position in bytes as an Integer:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"julia> block_pos[\"POS\"]\n1234567","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"and can be used with read_block by passing it to the keyword argument block_position:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"gas_pos = read_block(filename, \"POS\", parttype=0, block_position=block_pos[\"POS\"])\ngas_vel = read_block(filename, \"VEL\", parttype=0, block_position=block_pos[\"VEL\"])\ngas_rho = read_block(filename, \"RHO\", parttype=0, block_position=block_pos[\"RHO\"])","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Please note that this only makes sense if you plan to read in multiple blocks. If the keyword argument is left out read_block will look for the block positions by itself.","category":"page"},{"location":"file_infos/#Reading-the-INFO-block","page":"File Infos","title":"Reading the INFO block","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you compiled Gadget with WRITE_INFO_BLOCK the snapshot contains a block INFO that holds information on the name, datatype, dimensionality and presence per particle for each block. This simplifies read-in greatly and is always recommended! You can obtain this block by using:","category":"page"},{"location":"file_infos/#GadgetIO.read_info","page":"File Infos","title":"GadgetIO.read_info","text":"read_info(filename; verbose::Bool=false)\n\nReads the info block of a snapshot and returns the information in an array of InfoLine types. If verbose=true the blocknames are also printed to console.\n\n\n\n\n\n","category":"function"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This returns an Array{InfoLine,1}, where InfoLine is:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"struct InfoLine([  block_name=\"\", data_type=Float32, n_dim=Int32(0),\n                is_present=zeros(Int32, 6) ])","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Contains the data of a single entry in the INFO block of a Gadget snapshot. The data can be accessed via the fields:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Name Meaning\nblock_name::String name of the data block, e.g. \"POS\"\ndata_type::DataType datatype of the block, e.g. Float32 for single precision, Float64 for double\nn_dim::Int32 number of dimensions of the block, usually 1 or 3\nis_present::Vector{Int32} array of flags for which particle type this block is present,\n e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ],\n or gas + BHs: [ 1, 0, 0, 0, 0, 1 ]","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"You can use this as well to speed up read-in by passing the relevant Array entry to the keyword argument info in read_block:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"gas_pos = read_block(filename, \"POS\", parttype=0, info=info[1])","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This can of course be combined with reading the block positions for additional speedup.","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If there is no INFO block in the simulation you need to construct the InfoLine struct yourself and pass it to read_block like in the previous example.","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager, so in the REPL type:","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add GadgetIO","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"read_snapshots/#Read-Snapshot-Data","page":"Reading Snapshots","title":"Read Snapshot Data","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"NOTE","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"From v0.4 and up snapshots are read in proper column-major order, as it should be for Julia. This means that position data for particle i neads be accessed as:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"x = pos[1,i]\ny = pos[2,i]\nz = pos[3,i]","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"GadgetIO.jl is specialized to read Gadget snapshots of Format 2. The structure of a Format 2 snapshot is as follows:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"8              # size of the blockname block (Int32)\nBLOCKNAME      # Blockname (4*Char)\n8+SIZE_BLOCK   # number of bytes to skip if block should not be read\n8              # end of blockname block\n\nSIZE_BLOCK     # size of the current block in bytes\n{...}          # content of the block ordered by particle type\nSIZE_BLOCK     # end of the current block","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"which repeats for every block.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"It is also possible to read snapshots of Format 1. The structure of a Format 1 snapshot is as follows:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"SIZE_BLOCK     # size of the current block in bytes\n{...}          # content of the block ordered by particle type\nSIZE_BLOCK     # end of the current block","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"As it is the same as for Format 2, except without the blockname information, this means that the order of the blocks is expected to be standardized.","category":"page"},{"location":"read_snapshots/#Filename","page":"Reading Snapshots","title":"Filename","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Before we get started, a short bit for clarification: In what follows we need to distinguish between filename and filebase. For small simulations the data is written to a single file. In that case you can simply supply an absolute, or relative path to the one snapshot file as filename.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For larger simulations the data may be distributed over multiple files, which again may be in individual snapshot directories. With the snapshots being distributed over multiple files you need to supply the base-name filebase. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the filebase is","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"filebase = \"path/to/your/snapshot/directories/snapdir_140/snap_140\"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"In the relevant functions GadgetIO.jl will then automatically loop through the sub-snapshots which end in \".0\", \".1\", ... , \".N\".","category":"page"},{"location":"read_snapshots/#Reading-a-snapshot","page":"Reading Snapshots","title":"Reading a snapshot","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"There are multiple ways to read the data in the snapshot","category":"page"},{"location":"read_snapshots/#Full-snapshot","page":"Reading Snapshots","title":"Full snapshot","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to read a simulation snapshot into memory with GadgetIO.jl, it's as easy as this:","category":"page"},{"location":"read_snapshots/#GadgetIO.read_snap","page":"Reading Snapshots","title":"GadgetIO.read_snap","text":"read_snap(filename::String [, blockname::String=\"\", parttype::Integer=-1] )\n\nWrapper function to read snapshot in various ways: filename only: returns the entire snapshot as a dictionary. blockname: Returns only that block. If parttype specified only for that particle type.\n\nExamples\n\njulia> gas_pos = read_snap(filename, \"POS\", 0)\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with the header information in data[\"Header\"] and the blocks sorted by particle type.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"As an example, this is how you would access the positions of the gas particles:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"    data[\"Parttype0\"][\"POS\"]","category":"page"},{"location":"read_snapshots/#Specific-blocks","page":"Reading Snapshots","title":"Specific blocks","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function read_block with a specified blockname and particle type.","category":"page"},{"location":"read_snapshots/#GadgetIO.read_block","page":"Reading Snapshots","title":"GadgetIO.read_block","text":"read_block(filename::String, block_id::Union{String, Integer};\n            parttype::Integer=0,\n            block_position::Integer=-1,\n            info::Union{Nothing,InfoLine}=nothing,\n            h::Union{Nothing,SnapshotHeader}=nothing,\n            offset=0, n_to_read=-1)\n\nReads a block in a snapshot with block_id as a given name or position in the file. Defaults to reading gas particles. Block Names are case sensitive.\n\nKeyword Arguments\n\nparttype: Which particle type to read (0-indexed)\n0: Gas (default)\n1: Dark Matter\n2: Boundary\n3: Bulge\n4: Stars \n5: Black Holes\n-1: All particle types\nblock_position: Position of the block in the data file [bytes]. Can be used to speed up IO.\ninfo: InfoLine for the given block. Can be used to speed up IO, or if no INFO block is present.\nh: SnapshotHeader for given file. Can be used to speed up IO.\noffset: Adds an offset to start reading the block at a later point. Can be used for sub-IO.\nn_to_read: How many particles to read. Can be used for sub-IO.\n\nExamples (Format 2)\n\nIn case an INFO block is present:\n\ngas_pos = read_block(filename, \"POS\", parttype=0)\n\nIf not you need to supply your own InfoLine\n\npos_info = InfoLine(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\ngas_pos = read_block(filename, \"POS\", info=pos_info, parttype=0)\n\n# Examples (Format 1)\nIn case you want to read the default blocks:\n\njulia gaspos = readblock(filename, 1, parttype=0)\n\nIf not you need to supply your own `InfoLine`\n\njulia posinfo = InfoLine(\"\", Float32, 1, [1, 1, 1, 1, 1, 1]) gaspos = readblock(filename, 1, info=posinfo, parttype=0) ```\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return an array of the datatype of your simulation, usually Float32.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If the snapshot has no info block there are a number of default InfoLines.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"In case the snapshot has no info block and the block you want to read is not covered by the default InfoLines you can still read the specific block by supplying a hand-constructed InfoLine struct and passing that to the function read_block:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"pos_info = InfoLine(\"POS\", Float32, 3, [1,1,1,1,1,1])\npos      = read_block(filename, \"POS\", info=pos_info, parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For Format 1 you need to pass it a block number, instead of name and an InfoLine if the block order/datatype differs from the default:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"# default behaviour to read DM particles\npos = read_block(filename, 1, parttype=1)\n\n# custom block, not typical for Format 1\nbfld_info = InfoLine(\"BFLD\", Float64, 3, [1,0,0,0,0,0])\nbfld      = read_block(filename, 8, info=bfld_info, parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Since v0.5 read_snap and read_block also work if you pass them a file_base.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Since v0.7 read_block reads the full block if parttype=-1 is set.","category":"page"},{"location":"read_snapshots/#Read-Subvolumes","page":"Reading Snapshots","title":"Read Subvolumes","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you only want to read a subvolume of the whole simulation you can do this in two ways.","category":"page"},{"location":"read_snapshots/#Cubes","page":"Reading Snapshots","title":"Cubes","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"To get all particles within a cubic box of the simulation you can use the functions read_particles_in_box or read_particles_in_volume.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_in_box takes a box defined by a lower-left corner and an upper-right corner and reads all requested blocks and particles in that volume.","category":"page"},{"location":"read_snapshots/#GadgetIO.read_particles_in_box","page":"Reading Snapshots","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                    corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                    parttype::Integer=0, verbose::Bool=true,\n                    use_keys::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type. Returns a dictionary with all requested blocks. If use_keys=true it uses Peano-Hilbert keys to constrain the read-in, otherwise it uses a brute-force read-in with a filter function. Peano-Hilbert key based read-in is significantly faster.\n\n\n\n\n\nread_particles_in_box(filename::String, block::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nLike read_particles_in_box but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"You can define an array of blocks you want to read, these will be read into a dictionary.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_in_volume is a simple wrapper around read_particles_in_box, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.","category":"page"},{"location":"read_snapshots/#GadgetIO.read_particles_in_volume","page":"Reading Snapshots","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box encapsulating a volume defined by center position and radius for a given particle type. Returns a dictionary with all requested blocks.\n\nSee also: read_particles_in_box\n\n\n\n\n\nread_particles_in_box(filename::String, block::String,\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_volume but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_volume\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/#Arbitrary-Geometries","page":"Reading Snapshots","title":"Arbitrary Geometries","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For reading particles in more complex geometries you can use","category":"page"},{"location":"read_snapshots/#GadgetIO.read_particles_in_geometry","page":"Reading Snapshots","title":"GadgetIO.read_particles_in_geometry","text":"read_particles_in_geometry( filename::String, blocks::Vector{String},\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with all requested blocks. If shift_across_box_border is true, the particles are moved beyond the borders of a periodic box, if false, the periodicity of the box is still accounted for, but the particles' positions are not shifted.\n\n\n\n\n\nread_particles_in_geometry( filename::String, block::String,\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with the requested block.\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"You can use built-in geometries like GadgetCube, GadgetSphere and GadgetCylinder.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to extend the functionality you can define your own geometry as","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"struct YourGeometry{T} <: AbstractGadgetGeometry\n    prop1::Vector{T}\n    prop2::Vector{T}\n    prop3::T\n    (...)\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"and define the functions GadgetIO.get_geometry_box_corners and GadgetIO.get_geometry_mask. GadgetIO.get_geometry_box_corners has to return a Tuple of two vectors which define the lower left and upper right corner of a box that contains the geometry. GadgetIO.get_geometry_mask has to return an array of indices for which pos is contained in the geometry.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"In all functions parttype defines the particle type to be read, as in the previous read functions and verbose gives console output. There are also multiple dispatch versions of all functions available that only take a single block as input and return an array with the values instead of a dictionary.","category":"page"},{"location":"read_snapshots/#Peano-Hilbert-key-based-reading","page":"Reading Snapshots","title":"Peano-Hilbert key based reading","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=true (which is the default case) it constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary. This is considerably faster than the brute-force attempt.","category":"page"},{"location":"read_snapshots/#Brute-Force-Reading","page":"Reading Snapshots","title":"Brute-Force Reading","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=false it reads all particles over all distributed files which are contained in the requested subvolume. This takes quite a lot longer than the key based reading, but sometimes it's the only option. To speed this up you can apply the filtering only once and store the Read positions.","category":"page"},{"location":"read_snapshots/#Custom-Filtering","page":"Reading Snapshots","title":"Custom Filtering","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to read multiple blocks in a simulation whose snapshots have been distributed over a number of sub-snapshots you can use read_blocks_filtered.","category":"page"},{"location":"read_snapshots/#GadgetIO.read_blocks_filtered","page":"Reading Snapshots","title":"GadgetIO.read_blocks_filtered","text":"read_blocks_filtered( snap_base::String, blocks::Array{String};\n                            filter_function::Union{Function, Nothing}=nothing, \n                            read_positions::Union{Dict, Nothing}=nothing, \n                            parttype::Integer=0, verbose::Bool=true )\n\nReads the specified blocks from all distributed files where particles pass the filter_function, or are given by a Dict of read_positions. For read_positions please see find_read_positions.\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will read the specified blocks for all particles that pass the filter_function. This can be useful if you don't know where the region you are interested in is located and don't have enough memory to read in all particles. Alternatively you can also provide a Dict with read_positions as described in Read positions.","category":"page"},{"location":"read_snapshots/#Filter-functions","page":"Reading Snapshots","title":"Filter functions","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"The filter_function can be any function that takes a String input and returns an Array of Integers, or CartesianCoordinates. For example, if you want to filter all particles with a Mach number larger than 1:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function mach_gt_1(snap_file)\n    mach = read_snap(snap_file, \"MACH\", 0)\n    sel  = findall( mach .> 1.0 )\n    return sel\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Or if you want to trick the function into reading all particles after all:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function pass_all(snap_file)\n    h = read_header(snap_file)\n    return collect(1:h.npart[1])\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"As an example, to read positions, velocity and ID of all shocked particles from distributed snapshots use","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"ID\"]\ndata = read_blocks_filtered(snap_base, blocks, filter_function=mach_gt_1, parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Just as a reminder from above you can read single blocks into an array by using read_snap and read_block:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"pos = read_block(snap_base, \"POS\", parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This requiers GadgetIO.jl v0.5 though.","category":"page"},{"location":"read_snapshots/#Read-positions","page":"Reading Snapshots","title":"Read positions","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"To avoid having to filter all files each time you want to read a snapshot you can also split the steps. You can first filter the particles to find the positions of the particles within the data blocks with","category":"page"},{"location":"read_snapshots/#GadgetIO.find_read_positions","page":"Reading Snapshots","title":"GadgetIO.find_read_positions","text":"find_read_positions( snap_base::String, filter_function::Function)\n\nFinds the number of particles and their storage location in a snapshot directory that pass the filter_function.\n\n\n\n\n\nfind_read_positions( snap_base::String, geometry::AbstractGadgetGeometry;\n                     parttype::Integer=0,\n                     verbose::Bool=true )\n\nFinds the number of particles and their storage location in a snapshot directory that are contained in the space defined by geometry.\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"and then save the result as a binary file with","category":"page"},{"location":"read_snapshots/#GadgetIO.save_read_positions","page":"Reading Snapshots","title":"GadgetIO.save_read_positions","text":"save_read_positions(save_file::String, read_positions::Dict)\n\nSaves the relevant read-in positions to a binary file.\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"To re-use the read_positions you can load them from file using load_read_positions","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_positions = load_read_positions(save_file)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This can then be used to read any number of blocks with","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"ID\"]\ndata = read_blocks_filtered(snap_base, blocks, read_positions=read_positions, parttype=0)","category":"page"},{"location":"read_snapshots/#Reading-particles-by-referenced-ID","page":"Reading Snapshots","title":"Reading particles by referenced ID","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to select specific particles to read from an array of IDs you can do this with","category":"page"},{"location":"read_snapshots/#GadgetIO.read_particles_by_id","page":"Reading Snapshots","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns all requested blocks as entries in a Dict.\n\n\n\n\n\nread_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     block::String; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns the requested block as an Array.\n\n\n\n\n\n","category":"function"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"snap_base defines the target snapshot, or the snapshot basename, selected_ids contains the list of IDs of the particles you want to read and blocks containes the blocknames of the blocks you want to read. If the simulation is too large to read the whole snapshot into memory you can give values for pos0 and r0 to read only a specific region with read_particles_in_volume. See Read Subvolumes for details on this.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with all requested blocks.","category":"page"},{"location":"read_snapshots/#Example","page":"Reading Snapshots","title":"Example","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Assuming pos_halo is the position of the center of mass of the halo and r_vir is its virial radius you read the data with","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"MASS\", \"RHO\", \"HSML\"]\n\ndata   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,\n                                  parttype=0,\n                                  verbose=true)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with the blocks as keys and containing the arrays for the particles.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"data[\"POS\"]  # array of positions\ndata[\"RHO\"]  # array of densities\n(...)","category":"page"},{"location":"write_data/#Write-Data","page":"Writing Data","title":"Write Data","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"GadgetIO.jl can write snapshots that can be used as initial conditions.","category":"page"},{"location":"write_data/#Format-2","page":"Writing Data","title":"Format 2","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"The safest way to write snapshots is in Format 2. Simply set up your header object and the arrays you want to write in the correct data format. For the header this is the struct GadgetIO.SnapshotHeader and for data its usually Array{Float32,2}. You can then write an initial condition file by writing the header and the individual data blocks.","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"f = open(filename, \"w\")\nwrite_header(f, header)\nwrite_block( f,  pos, \"POS\")\nwrite_block( f,  vel, \"VEL\")\nwrite_block( f,  id,  \"ID\")\nclose(f)","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Please note that you have to combine the arrays for individual particles in the correct order.","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"If you want to write the INFO block as well you can use","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_info_block(f, info)","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"where info is a Vector of GadgetIO.InfoLine.","category":"page"},{"location":"write_data/#Format-1","page":"Writing Data","title":"Format 1","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Writing in format 1 works the same as above, but you need different function values. Also you need to make sure the blocks are in the order gadget expects them to be!","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"f = open(filename, \"w\")\nwrite_header(f, header, snap_format=1)\nwrite_block( f,  pos,   snap_format=1)\nwrite_block( f,  vel,   snap_format=1)\nwrite_block( f,  id,    snap_format=1)\nclose(f)","category":"page"},{"location":"#GadgetIO.jl","page":"Table of Contents","title":"GadgetIO.jl","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"This package provides IO functionality to work with the Smoothed-Particle Hydrodynamics code Gadget by Volker Springel.","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"It is taylored for working with the development version of P-Gadget3, specifically OpenGadget3 developed by Klaus Dolag and contributers. Development is focused on IO for Binary Format 2. A lot of the routines are based on IDL scripts by Klaus Dolag (not public).","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"If you use GadgetIO.jl in your publications please cite Bss & Valenzuela.","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\",\n          \"install.md\",\n          \"file_infos.md\",\n          \"read_snapshots.md\", \n          \"read_subfind.md\",\n          \"write_data.md\",\n          \"api.md\" \n        ]\nDepth = 3","category":"page"}]
}
