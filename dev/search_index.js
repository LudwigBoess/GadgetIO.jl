var documenterSearchIndex = {"docs":
[{"location":"read_subfind/#Read-Subfind-Data","page":"Reading Subfind","title":"Read Subfind Data","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"Gadget contains an on-the-fly halo-finder as described in Springel et al (2001) or Dolag et al (2009). This sections provides an overview of the functions you can use to work with this output. Please note that you need to compile Gadget with WRITE_SUB_IN_SNAP_FORMAT to use this functionality.","category":"page"},{"location":"read_subfind/#Reading-the-header","page":"Reading Subfind","title":"Reading the header","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"As in the normal snapshot the subfind output also contains a HEAD block with useful information. You can read the header of the subfind output into a SubfindHeader object","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"struct SubfindHeader\n    nhalos::Int32                       # number of halos in the output file\n    nsubhalos::Int32                    # number of subhalos in the output file\n    nfof::Int32                         # number of particles in the FoF\n    ngroups::Int32                      # number of large groups in the output file\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    tothalos::UInt32                    # total number of halos over all output files\n    totsubhalos::UInt32                 # total number of subhalos over all output files\n    totfof::UInt32                      # total number of particles in the FoF\n    totgroups::UInt32                   # total number of large groups over all output files\n    num_colors::Int32                   # number of colors\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32\nend","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"using","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"h = read_subfind_header(filename::String)","category":"page"},{"location":"read_subfind/#Reading-the-subfind-files","page":"Reading Subfind","title":"Reading the subfind files","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"For convenience you can use a helper function provided by GadgetIO to read the block of the subfind output. Since each of the blocks is only relevant for either halos, subhalos, Fof or large groups you don't need to define a particly type, aka halo type in this case.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"So in order to read the virial radius of the halos in a file you can simply use","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"R_vir = read_subfind(filename, \"RVIR\")","category":"page"},{"location":"read_subfind/#Filtered-read-in","page":"Reading Subfind","title":"Filtered read-in","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to read specific halos from the subfind output you can use the function","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function, nfiles::Integer=1)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"This will return an array of HaloIDs ","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"struct HaloID\n    file::Int64\n    id::Int64\nend","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"You can use this to read specific files with read_subfind and select the array entry via the id field.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"The filter_function argument takes any function that takes one input argument and returns true if the requirement is fulfilled, or false if not.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"So to find e.g. all halos with a virial mass largert than 10^15 M_odot you can use","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\n\nfiltered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"This will search all subfind files in the directory and check if they fulfill the filter. Since halos in subfind files are sorted by mass you can also supply a number of files to search with the argument nfiles. That way, if you are looking for a very massive halo you can constrian the reading and filtering to only the first N files to save time.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want more complex filtering you can also just pass a filter_function that takes a filename as an input and returns an Array of Integers, or CartesianCoordinates, like was the case in Filter functions.","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"filtered_subfind = filter_subfind(filebase, filter_function)","category":"page"},{"location":"read_subfind/#Reading-halo-property-by-HaloID","page":"Reading Subfind","title":"Reading halo property by HaloID","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"You can read any property of the halo that passed the filter_function (see Filtered read-in) by using read_halo_prop. So if you want to read e.g. the virial radius for the first halo that passed your filter_function","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir = read_halo_prop(filebase, filtered_subfind[1], \"MVIR\")","category":"page"},{"location":"read_subfind/#Relating-to-Magneticum","page":"Reading Subfind","title":"Relating to Magneticum","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you work with the Magneticum simulation you may be given a global halo id. To read a halo property from a global halo id and convert it to a HaloID you can use read_halo_prop_and_id. So for example if you have the global halo id i_global and want to read the corresponding virial mass you can use","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"mvir, halo_id = read_halo_prop_and_id(filebase, i_global, \"MVIR\")","category":"page"},{"location":"read_subfind/#Reading-particles-in-a-halo","page":"Reading Subfind","title":"Reading particles in a halo","text":"","category":"section"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"If you want to read all particles associated with a FoF halo you can do this with the function read_particles_in_halo","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"read_particles_in_halo( snap_base::String,   blocks::Array{String},\n                        sub_base::String,    halo::HaloID; \n                        rad_scale::Real=1.0, halo_type::Integer=1,\n                        parttype::Integer=0, verbose::Bool=true)","category":"page"},{"location":"read_subfind/","page":"Reading Subfind","title":"Reading Subfind","text":"This reads all blocks defined in blocks for the halo into a dictionary. snap_base and sub_base should point to the snap and subfind filebase as in other functions, or the files if you only have one file. The HaloID point to the selected halo. halo_type should be set to 1 for halos and 2 for subhalos.  If you didn't get all the particles you were looking for it might be that the search radius for the read-in was too small. rad_scale defines the multiplication factor for the search radius. For halos the default search radius is r_200 and for subhalos it's the half-mass radius.","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.block_present","page":"API reference","title":"GadgetIO.block_present","text":"block_present(filename::String, blockname::String, blocks::Vector{String}=[\"\"])\n\nChecks if a given block is present in the snapshot file, or in the supplied blocks Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.filter_cube-Tuple{String, Array{var\"#s10\", N} where {var\"#s10\"<:Real, N}, Array{var\"#s11\", N} where {var\"#s11\"<:Real, N}}","page":"API reference","title":"GadgetIO.filter_cube","text":"filter_cube(snap_file::String, corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real}, \n                      parttype::Integer)\n\nReads positions from snap_file and returns the indices of particles contained in a box defined by corner_lowerleft and corner_upperright.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_cylinder-Tuple{String, Array{var\"#s7\", N} where {var\"#s7\"<:Real, N}, Array{var\"#s6\", N} where {var\"#s6\"<:Real, N}, Real}","page":"API reference","title":"GadgetIO.filter_cylinder","text":"filter_cylinder(filename::String, pt1::Array{<:Real}, pt2::Array{<:Real}, r::Real)\n\nReads the positions contained in a file and returns the indices of particles contained in a cylinder defined by the endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_subfind","page":"API reference","title":"GadgetIO.filter_subfind","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function [, nfiles::Integer=1])\n\nSelects entries in subfind block that fulfill the 'filter_funcion' requirements and returns a 'SubfindFilter' object.\n\nExamples\n\njulia> find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\nfind_mass_gt_1e15 (generic function with 1 method)\njulia> filtered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.filter_subfind-2","page":"API reference","title":"GadgetIO.filter_subfind","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function [, nfiles::Integer=1])\n\nSelects entries in subfind block that fulfill the 'filter_funcion' requirements and returns a 'SubfindFilter' object.\n\nExamples\n\njulia> find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\nfind_mass_gt_1e15 (generic function with 1 method)\njulia> filtered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_most_massive_halo","page":"API reference","title":"GadgetIO.find_most_massive_halo","text":"find_most_massive_halo(filebase::String [, nfiles::Int=1])\n\nReads the selected file and its subfiles and returns position, virial radius and a HaloID object that contains the subfile which contains the most massive halo and the position in the block.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_read_positions-Tuple{String, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions( snap_base::String, geometry::AbstractGadgetGeometry;\n                     parttype::Integer=0,\n                     verbose::Bool=true )\n\nFinds the number of particles and their storage location in a snapshot directory that are contained in the space defined by geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_read_positions-Tuple{String, Function}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions( snap_base::String, filter_function::Function)\n\nFinds the number of particles and their storage location in a snapshot directory that pass the filter_function.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_read_positions-Tuple{Vector{var\"#s5\"} where var\"#s5\"<:Integer, String, AbstractVector{String}, Integer, Vector{var\"#s4\"} where var\"#s4\"<:Integer, Vector{InfoLine}, Bool}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions(files::Vector{<:Integer}, filebase::String, \n                    blocks::AbstractVector{String}, parttype::Integer,\n                    keylist::Vector{<:Integer}, key_info::Vector{InfoLine},\n                    verbose::Bool)\n\nHelper function to get positions and length of particle blocks in files.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list-Tuple{Vector{var\"#s13\"} where var\"#s13\"<:Integer, Vector{var\"#s12\"} where var\"#s12\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list","text":"get_index_list(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nFinds the indices at which list_to_check contains elements from list_to_find. If both either of the lists are not sorted it uses a Dict lookup, otherwise it uses a Vector forward-search.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_dict-Tuple{String}","page":"API reference","title":"GadgetIO.head_to_dict","text":"head_to_dict(filename::String)\n\nReturns the header of a snapshot as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_obj-Tuple{Any}","page":"API reference","title":"GadgetIO.head_to_obj","text":"head_to_obj(filename::String)\n\nReturns the header of a snapshot as a SnapshotHeader object.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.load_read_positions-Tuple{String}","page":"API reference","title":"GadgetIO.load_read_positions","text":"load_read_positions(read_positions_file::String)\n\nLoads the relevant read-in positions from a binary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.print_blocks-Tuple{String}","page":"API reference","title":"GadgetIO.print_blocks","text":"print_blocks(filename::String; verbose::Bool=true)\n\nReads the block names of blocks in a snapshot and returns them in an array. Outputs them to console if verbose=true\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block-Tuple{String, String}","page":"API reference","title":"GadgetIO.read_block","text":"read_block(filename::String, blockname::String;\n                            info::InfoLine=InfoLine(),\n                            parttype::Integer=-1)\n\nReads a block in a snapshot with given name. Names are case sensitive.\n\nExamples\n\njulia> pos_info = InfoLine(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\n[...]\njulia> gas_pos = read_block(filename, \"POS\", info=pos_info, parttype=0)\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_blocks_over_all_files-Tuple{String, Array{String, N} where N}","page":"API reference","title":"GadgetIO.read_blocks_over_all_files","text":"read_blocks_over_all_files( snap_base::String, blocks::Array{String};\n                            filter_function::Union{Function, Nothing}=nothing, \n                            read_positions::Union{Dict, Nothing}=nothing, \n                            parttype::Integer=0, verbose::Bool=true )\n\nReads the specified blocks from all distributed files where particles pass the filter_function, or are given by a Dict of read_positions. For read_positions please see find_read_positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop-Tuple{String, HaloID, String}","page":"API reference","title":"GadgetIO.read_halo_prop","text":"read_halo_prop(filebase::String, haloid::HaloID, blockname::String; verbose::Bool=true)\n\nGet halo property from block blockname by halo id. Returns an array or scalar depending on the block type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_halo_prop_and_id","page":"API reference","title":"GadgetIO.read_halo_prop_and_id","text":"read_halo_prop_and_id(filebase::String, i_global::Integer, blockname::String, nfiles::Integer=1; verbose::Bool=true)\n\nGet halo property from block blockname by global halo index i_global (zero-based index). nfiles should generally be set to h.num_files, obtained from read_header.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.read_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_header","text":"read_header(filename::String)\n\nReads the header of a snapshot file or file base (without .0, .1, etc.) and returns a SnapshotHeader object.\n\nSee also: head_to_obj\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_ids_in_halo-Tuple{String, HaloID}","page":"API reference","title":"GadgetIO.read_ids_in_halo","text":"read_ids_in_halo( sub_base::String, halo::HaloID; \n                  halo_type::Integer=1, verbose::Bool=true)\n\nReads the IDs of all particles contained in a halo.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info-Tuple{String}","page":"API reference","title":"GadgetIO.read_info","text":"read_info(filename; verbose::Bool=false)\n\nReads the info block of a snapshot and returns the information in an array of InfoLine types. If verbose=true the blocknames are also printed to console.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String, Array{var\"#s624\", N} where {var\"#s624\"<:Integer, N}, Array{String, N} where N}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns all requested blocks as entries in a Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String, Array{var\"#s628\", N} where {var\"#s628\"<:Integer, N}, String}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     block::String; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns the requested block as an Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String, String, Array{var\"#s628\", N} where {var\"#s628\"<:Real, N}, Array{var\"#s627\", N} where {var\"#s627\"<:Real, N}}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nLike read_particles_in_box but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String, Vector{String}, Array{var\"#s628\", N} where {var\"#s628\"<:Real, N}, Array{var\"#s627\", N} where {var\"#s627\"<:Real, N}}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type. Returns a dictionary with all requested blocks. If use_keys=true it uses Peano-Hilbert keys to constrain the read-in, otherwise it uses a brute-force read-in with a filter function. Peano-Hilbert key based read-in is significantly faster.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_geometry-Tuple{String, String, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.read_particles_in_geometry","text":"read_particles_in_geometry( filename::String, block::String,\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_geometry-Tuple{String, Vector{String}, AbstractGadgetGeometry}","page":"API reference","title":"GadgetIO.read_particles_in_geometry","text":"read_particles_in_geometry( filename::String, blocks::Vector{String},\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true, do_shift_across_box_border::Bool=true)\n\nReads all particles within a space defined by an AbstractGeometry struct for a given particle type.  Returns a dictionary with all requested blocks. If shift_across_box_border is true, the particles are moved beyond the borders of a periodic box, if false, the periodicity of the box is still accounted for, but the particles' positions are not shifted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String, Array{String, N} where N, String, HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo(snap_base::String, blocks::Array{String},\n                            sub_base::String, halo::HaloID; \n                            radius::Union{Real,Nothing}=nothing,\n                            rad_scale::Real=1.0, halo_type::Integer=1,\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns a Dict with each of the blocks as entries.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String, String, String, HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo( snap_base::String, block::String,\n                        sub_base::String, halo::HaloID; \n                        kwargs...)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. If radius is given (in simulation units), particles are read within at least this radius times rad_scale. Otherwise, R200, RMEA, or RHMS times rad_scale is used depending on halo_type (1, 1, and 2, respectively). Returns an Array with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String, String, Any, Any}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::String,\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_volume but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_volume\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String, Vector{String}, Array{var\"#s631\", N} where {var\"#s631\"<:Real, N}, Real}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box encapsulating a volume defined by center position and radius for a given particle type. Returns a dictionary with all requested blocks.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_snap","page":"API reference","title":"GadgetIO.read_snap","text":"read_snap(filename::String [, blockname::String=\"\", parttype::Integer=-1] )\n\nWrapper function to read snapshot in various ways: filename only: returns the entire snapshot as a dictionary. blockname: Returns only that block. If parttype specified only for that particle type.\n\nExamples\n\njulia> gas_pos = read_snap(filename, \"POS\", 0)\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.read_subfind-Tuple{String, String}","page":"API reference","title":"GadgetIO.read_subfind","text":"read_subfind(filename::String, blockname::String)\n\nReads a block of a subfind file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subfind_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_subfind_header","text":"read_subfind_header(filename::String)\n\nReads the header of a subfind file or file base (without .0, .1, etc.) into a SubfindHeader struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.save_read_positions-Tuple{String, Any}","page":"API reference","title":"GadgetIO.save_read_positions","text":"save_read_positions(read_positions_file::String, data)\n\nSaves the relevant read-in positions to a binary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.snap_to_dict","page":"API reference","title":"GadgetIO.snap_to_dict","text":"snap_to_dict(filename::String, try_info::Bool=true)\n\nReads whole snapshot into memory and returns a dictionary sorted by particle type and block names. Be cautious with large snapshots!\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_block","page":"API reference","title":"GadgetIO.write_block","text":"write_block(f::IOStream, data,\n            blockname::String=\"\";\n            snap_format::Integer=2)\n\nWrite data to a block to an opened file f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_header-Tuple{IOStream, SnapshotHeader}","page":"API reference","title":"GadgetIO.write_header","text":"write_header(f::IOStream, h::SnapshotHeader; snap_format::Integer=2)\n\nWrites the header block to an opened file f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#GadgetIO.GadgetCube","page":"API reference","title":"GadgetIO.GadgetCube","text":"struct GadgetCube{T} <: AbstractGadgetGeometry\n    corner_lower_left::Vector{T}\n    corner_upper_right::Vector{T}\nend\n\nDefines a cube by corner_lower_left and corner_upper_right.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetCylinder","page":"API reference","title":"GadgetIO.GadgetCylinder","text":"struct GadgetCylinder{T} <: AbstractGadgetGeometry\n    pos_start::Vector{T}\n    pos_end::Vector{T}\n    radius::T\nend\n\nDefines a cylinder by two end points pos_start and pos_start as well as a radius.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.GadgetSphere","page":"API reference","title":"GadgetIO.GadgetSphere","text":"struct GadgetSphere{T} <: AbstractGadgetGeometry\n    center::Vector{T}\n    radius::T\nend\n\nDefines a sphere by center and radius.  To be used for read_particles_in_geometry\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.HaloID","page":"API reference","title":"GadgetIO.HaloID","text":"struct HaloID\n    file::Int64\n    id::Int64\nend\n\nStores the subfile that contains the halo in file and the position in the block in id.\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.InfoLine","page":"API reference","title":"GadgetIO.InfoLine","text":"struct InfoLine([  block_name=\"\", data_type=Float32, n_dim=Int32(0),\n                            is_present=zeros(Int32, 6) ])\n\nContains the data of a single entry in the INFO block of a Gadget snapshot.\n\nFields\n\nName Meaning\nblock_name::String name of the data block, e.g. \"POS\"\ndata_type::DataType datatype of the block, e.g. Float32 for single precision, Float64 for double\nn_dim::Int32 number of dimensions of the block, usually 1 or 3\nis_present::Vector{Int32} array of flags for which particle type this block is present,\n e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ],\n or gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.SnapshotHeader","page":"API reference","title":"GadgetIO.SnapshotHeader","text":"mutable struct SnapshotHeader( [ **Fields ])\n\nContains the data of the HEAD block of a Gadget snapshot.\n\nFields\n\nName Meaning\nnpart::Vector{Int32} an array of particle numbers per type in this snapshot\nmassarr::Vector{Float64} an array of particle masses per type in this snapshot - if zero: MASS block present\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\nflag_sfr::Int32 1 if simulation was run with star formation, else 0\nflag_feedback::Int32 1 if simulation was run with stellar feedback, else 0\nnall::Vector{UInt32} total number of particles in the simulation\nflag_cooling::Int32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of snapshots over which the simulation is distributed\nomega_0::Float64 Omega matter\nboxsize::Float64 total size of the simulation box\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_stellarage::Int32 1 if simulation was run with stellar age, else 0\nflag_metals::Int32 1 if simulation was run with metals, else 0\nnpartTotalHighWord::Vector{UInt32} weird\nflag_entropy_instead_u::Int32 1 if snapshot U field contains entropy instead of internal energy, else 0\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\nlpt_scalingfactor::Float32 factor to use second order ic generation\nfill::Vector{Int32} the HEAD block needs to be filled with zeros to have a size of 256 bytes\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.SubfindHeader","page":"API reference","title":"GadgetIO.SubfindHeader","text":"struct SubfindHeader\n\nContains the data of the HEAD block in the subfind output\n\nFields\n\nName Meaning\nnhalos::Int32 number of halos in the output file\nnsubhalos::Int32 number of subhalos in the output file\nnfof::Int32 number of particles in the FoF\nngroups::Int32 number of large groups in the output file\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\ntothalos::UInt32 total number of halos over all output files\ntotsubhalos::UInt32 total number of subhalos over all output files\ntotfof::UInt32 total number of particles in the FoF\ntotgroups::UInt32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of files over which subfind data is distributed\nboxsize::Float64 total size of the simulation box\nomega_0::Float64 Omega matter\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.allocate_data_dict-Tuple{Array{String, N} where N, Integer, Array{InfoLine, N} where N, Bool}","page":"API reference","title":"GadgetIO.allocate_data_dict","text":"allocate_data_dict( blocks::Array{String}, N_to_read::Integer, \n                    snap_info::Array{InfoLine}, no_mass_block::Bool )\n\nHelper function to allocate the data Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_block_position-Tuple{String, String}","page":"API reference","title":"GadgetIO.check_block_position","text":"check_block_position(filename::String, blockname::String)\n\nHelper function to find read positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocks-Tuple{String, Array{String, N} where N}","page":"API reference","title":"GadgetIO.check_blocks","text":"check_blocks(snap_base::String, blocks::Array{String})\n\nCheck if all requested blocks are present.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocksize-Tuple{IOStream, Integer, Integer}","page":"API reference","title":"GadgetIO.check_blocksize","text":"check_blocksize(f::IOStream, position_before::Integer, blocksize_before::Integer)\n\nChecks for integer overflow in the size of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_in_cylinder-NTuple{4, Any}","page":"API reference","title":"GadgetIO.check_in_cylinder","text":"check_in_cylinder(x, pt1, pt2, r)\n\nChecks if a 3D point x is in a cylinder defined by its endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_info-Tuple{String, String}","page":"API reference","title":"GadgetIO.check_info","text":"check_info(filename::String, blockname::String)\n\nHelper function to read INFO block or construct InfoLine for MASS block, if no INFO block is present. Returns a single InfoLine struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.construct_matched_dict-Tuple{Dict{String, VecOrMat{T} where T}, Vector{String}, Vector{var\"#s633\"} where var\"#s633\"<:Integer}","page":"API reference","title":"GadgetIO.construct_matched_dict","text":"construct_matched_dict(data_in::Dict{String, Union{Vector{T}, Array{T,2}}}, \n                            blocks::Array{String,1}, matched::Array{<:Integer,1}) where T\n\nWrite all matching particles to a new dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_by_ids-Tuple{Array{var\"#s633\", N} where {var\"#s633\"<:Integer, N}, Array{var\"#s632\", N} where {var\"#s632\"<:Integer, N}}","page":"API reference","title":"GadgetIO.filter_by_ids","text":"filter_by_ids( selected_ids::Array{<:Integer}, ids::Array{<:Integer})\n\nChecks for matching IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_positions-Tuple{String, Array{var\"#s633\", N} where {var\"#s633\"<:Real, N}, Array{var\"#s632\", N} where {var\"#s632\"<:Real, N}, Integer}","page":"API reference","title":"GadgetIO.filter_positions","text":"filter_positions(snap_file::String, corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real}, \n                      parttype::Integer)\n\nReads positions from snap_file and returns the indices of particles contained in a box defined by corner_lowerleft and corner_upperright.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_sphere-Tuple{String, Array{var\"#s10\", N} where {var\"#s10\"<:Real, N}, Real}","page":"API reference","title":"GadgetIO.filter_sphere","text":"filter_sphere(filename::String, center::Array{<:Real}, r::Real; parttype::Integer=0)\n\nReads the positions contained in a file and returns the indices of particles contained in a cylinder defined by the endpoints pt1 and pt2 and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_files_for_keys-Tuple{String, Integer, Vector{var\"#s13\"} where var\"#s13\"<:Integer}","page":"API reference","title":"GadgetIO.find_files_for_keys","text":"find_files_for_keys(filebase::String, nfiles::Integer, keylist::Vector{<:Integer})\n\nSelects the files in which the particles associated with the given Peano-Hilbert keys are stored.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions","text":"get_block_positions(filename::String)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCube}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(cube::GadgetCube)\n\nReturns a Tuple with the lower left and upper right corner of a box which contains the cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetCylinder}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(cylinder::GadgetCylinder)\n\nReturns a tuple with the lower left and upper right corner of a box which contains the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_box_corners-Tuple{GadgetSphere}","page":"API reference","title":"GadgetIO.get_geometry_box_corners","text":"get_geometry_box_corners(sphere::GadgetSphere)\n\nReturns a tuple with the lower left and upper right corner of a box which contains the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetCube}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(sphere::GadgetCube)\n\nReturns the center of cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetCylinder}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(cylinder::GadgetCylinder)\n\nReturns the center of cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_center-Tuple{GadgetSphere}","page":"API reference","title":"GadgetIO.get_geometry_center","text":"function get_geometry_center(sphere::GadgetSphere)\n\nReturns the center of sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCube, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(cube::GadgetCube, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetCylinder, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(cylinder::GadgetCylinder, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_geometry_mask-Union{Tuple{T}, Tuple{GadgetSphere, Matrix{T}}} where T","page":"API reference","title":"GadgetIO.get_geometry_mask","text":"get_geometry_mask(sphere::GadgetSphere, pos::Matrix{T}) where T\n\nReturns the indices of all particles contained in the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_bounds-Tuple{Vector{var\"#s11\"} where var\"#s11\"<:Integer, Vector{var\"#s10\"} where var\"#s10\"<:Integer, Vector{var\"#s9\"} where var\"#s9\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_bounds","text":"get_index_bounds(ids::Vector{<:Integer}, low_bounds::Vector{<:Integer}, high_bounds::Vector{<:Integer})\n\nReturns sorted Vector of indices i, for which low_bounds[i] ≤ ids[j] ≤ high_bounds[i] for any j. All parameters ids, low_bounds, and high_bounds have to already be sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_bounds_Klaus-Tuple{Vector{var\"#s12\"} where var\"#s12\"<:Integer, Vector{var\"#s11\"} where var\"#s11\"<:Integer, Vector{var\"#s10\"} where var\"#s10\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_bounds_Klaus","text":"get_index_bounds_Klaus(ids::Vector{<:Integer}, low_bounds::Vector{<:Integer}, high_bounds::Vector{<:Integer})\n\nReturns sorted Vector of indices i, for which low_bounds[i] ≤ ids[j] ≤ high_bounds[i] for any j. All parameters ids, low_bounds, and high_bounds have to already be sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_arr-Tuple{Vector{var\"#s13\"} where var\"#s13\"<:Integer, Vector{var\"#s12\"} where var\"#s12\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list_arr","text":"get_index_list_arr(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses forward-searching in sorted array. Both arrays have to be sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_dict-Tuple{Vector{var\"#s10\"} where var\"#s10\"<:Integer, Vector{var\"#s9\"} where var\"#s9\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list_dict","text":"get_index_list_dict(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses a Dict for lookup -> slower than the array search, but works on unsorted arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_set-Tuple{Vector{var\"#s13\"} where var\"#s13\"<:Integer, Vector{var\"#s12\"} where var\"#s12\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list_set","text":"get_index_list_set(list_to_find::Vector{<:Integer}, list_to_check::Vector{<:Integer})\n\nGet positions in list_to_check where list_to_check matches list_to_find. Uses a Set for lookup -> slower than the array search get_index_list_arr, but works on unsorted arrays like get_index_list_dict, just faster.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_int_pos-Tuple{Real, Real, Real}","page":"API reference","title":"GadgetIO.get_int_pos","text":"get_int_pos(pos::Real, domain_corner::Real, domain_fac::Real )\n\nComputes the integer position along the PH line.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_keylist-Union{Tuple{T}, Tuple{GadgetIO.KeyHeader, Array{T, N} where N, Array{T, N} where N}} where T","page":"API reference","title":"GadgetIO.get_keylist","text":"get_keylist(h_key::KeyHeader, x0::Array{<:Real}, x1::Array{<:Real})\n\nGet all Peano-Hilbert keys for domain defined by the corner points x0 and x1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_pos_block_name-Tuple{Any, Any}","page":"API reference","title":"GadgetIO.get_pos_block_name","text":"function get_pos_block_name(sub_file, halo_type)\n\nReturns the position block name depending on the halo type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_prop_from_block-Tuple{Array, Integer}","page":"API reference","title":"GadgetIO.get_prop_from_block","text":"get_prop_from_block(block::Array, index::Integer)\n\nGet the full property from block at index. Returns an array or scalar depending on the block type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_rad_block_name-Tuple{Any, Any}","page":"API reference","title":"GadgetIO.get_rad_block_name","text":"function get_rad_block_name(sub_file, halo_type)\n\nReturns the radius block name depending on the halo type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.join_blocks-Tuple{Vector{var\"#s12\"} where var\"#s12\"<:Integer, Vector{var\"#s11\"} where var\"#s11\"<:Integer}","page":"API reference","title":"GadgetIO.join_blocks","text":"joinblocks(offsetkey, partperkey)\n\nJoins neighboring blocks to simplify read-in.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.peano_hilbert_key-NTuple{4, Integer}","page":"API reference","title":"GadgetIO.peano_hilbert_key","text":"peano_hilbert_key(bits::Integer, x::Integer, y::Integer, z::Integer)\n\nComputes a Peano-Hilbert key for an integer triplet (x,y,z) with x,y,z in the range between 0 and 2^bits-1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_data-Tuple{IOStream, DataType, Integer, Integer}","page":"API reference","title":"GadgetIO.read_block_data","text":"read_block_data(f::IOStream, data_type::DataType, n_dim::Integer, npart::Integer)\n\nReads the binary data in a block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_subsnaps-Tuple{String, String}","page":"API reference","title":"GadgetIO.read_block_subsnaps","text":"read_block_subsnaps(filename::String, blockname::String;\n                            info::InfoLine=InfoLine(),\n                            parttype::Integer=-1)\n\nReads a block over all sub-snapshots. Names are case sensitive.\n\nExamples\n\njulia> pos_info = InfoLine(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\n[...]\njulia> gas_pos = read_block(filename, \"POS\", info=pos_info, parttype=0)\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_with_offset!-Tuple{Any, Integer, String, Integer, InfoLine, Integer, Array{var\"#s11\", N} where {var\"#s11\"<:Integer, N}, Array{var\"#s10\", N} where {var\"#s10\"<:Integer, N}}","page":"API reference","title":"GadgetIO.read_block_with_offset!","text":"read_block_with_offset!(data, n_read::Integer, filename::String, pos0::Integer, info::InfoLine,\n                            offset::Integer, offset_key::Array{<:Integer}, \n                            part_per_key::Array{<:Integer} )\n\nRead part of a block to pre-allocated array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_bockname-Tuple{IOStream}","page":"API reference","title":"GadgetIO.read_bockname","text":"read_bockname(f::IOStream)\n\nReads the name of the Format 2 block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_filtered-NTuple{5, Any}","page":"API reference","title":"GadgetIO.read_filtered","text":"read_filtered(snap_file, blockname, parttype, block_position, matched)\n\nHelper function to return the correct filtered arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info_line-Tuple{IOStream}","page":"API reference","title":"GadgetIO.read_info_line","text":"read_info_line(f::IOStream)\n\nHelper function to read the binary data into a InfoLine struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_key_block-Tuple{String, Vector{InfoLine}, Vector{String}, String, Integer}","page":"API reference","title":"GadgetIO.read_key_block","text":"read_key_block( filename_keyfile::String, key_info::Vector{InfoLine}, \n                fields::Vector{String}, key::String, parttype::Integer)\n\nReturns key block for different key. Valid values of key: KEY, NKEY, OKEY\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_key_index-Tuple{String}","page":"API reference","title":"GadgetIO.read_key_index","text":"read_key_index(file_key_index::String)\n\nReads the .key.index file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_keyheader-Tuple{String}","page":"API reference","title":"GadgetIO.read_keyheader","text":"read_keyheader(filename::String)\n\nReads the header of a .key file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id_single_file-Tuple{String, Array{var\"#s631\", N} where {var\"#s631\"<:Integer, N}, Array{String, N} where N, Integer}","page":"API reference","title":"GadgetIO.read_particles_by_id_single_file","text":"read_particles_by_id_single_file(snap_file::String, halo_ids::Array{<:Integer}, \n                                      blocks::Array{String}, parttype::Integer)\n\nHelper function to read the matching IDs of particles in one whole file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box_peano-Tuple{String, Vector{String}, Array{var\"#s597\", N} where {var\"#s597\"<:Real, N}, Array{var\"#s598\", N} where {var\"#s598\"<:Real, N}}","page":"API reference","title":"GadgetIO.read_particles_in_box_peano","text":"read_particles_in_box_peano(filename::String, blocks::Vector{String},\n                            corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                            parttype::Integer=0, verbose::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type based on peano hilbert key reading. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_pids-Tuple{String, Integer, Integer}","page":"API reference","title":"GadgetIO.read_pids","text":"read_pids(sub_base::String, offset::Integer, N_ids::Integer)\n\nReads the PID block in the subfind output.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subsnaps-Tuple{String, String, Integer, InfoLine, SnapshotHeader}","page":"API reference","title":"GadgetIO.read_subsnaps","text":"read_subsnaps(filebase::String, blockname::String, parttype::Integer,\n                      info::InfoLine, h_global::SnapshotHeader)\n\nReads a block over distributed files and returns it in one large Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.reduce_read_positions-Tuple{Array{var\"#s633\", N} where {var\"#s633\"<:Integer, N}}","page":"API reference","title":"GadgetIO.reduce_read_positions","text":"reduce_read_positions(sel::Array{<:Integer})\n\nReduces the individual read positions by finding sub-ranges.  Returns an array of read indices and an array with the number of entries per index.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.select_file-Tuple{String, Integer}","page":"API reference","title":"GadgetIO.select_file","text":"select_file(filebase::String, filenum::Integer)\n\nChecks if the requested files exists and returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.shift_across_box_border-NTuple{4, Real}","page":"API reference","title":"GadgetIO.shift_across_box_border","text":"shift_across_box_border(x::Real, x_halo::Real, boxsize::Real, boxsize_half::Real)\n\nShift coordinate x across the box border if the zero coordinate x₀ is on the other side.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"api/#GadgetIO.KeyHeader","page":"API reference","title":"GadgetIO.KeyHeader","text":"struct KeyHeader\n\nHelper struct to store header information of .key files.\n\nFields\n\nName Meaning\nnkeys_file Number of keys in this .key file\ndomain_corners Corners of the domains defined by these keys\ndomain_fac Factor needed for reconstructung int positions\nbits Size of PH keys it bits\nnkeys_total Total number of keys in all files\nnkeys_total_highword Total number of keys in all files\n\n\n\n\n\n","category":"type"},{"location":"file_infos/#File-information","page":"File Infos","title":"File information","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Since Gadget outputs in binary format it can be quite tedious to see what is actually contained in the file. For this GadgetIO provides a number of helper functions.","category":"page"},{"location":"file_infos/#Reading-the-header","page":"File Infos","title":"Reading the header","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"The header block (HEAD) contains a number of informations about the file, for example how many particles of which kind are contained in the file, the current time or redshift, the cosmological parameters and so on.","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"The most convenient way to deal with this data is to read the header block into a SnapshotHeader struct:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":" h = read_header(filename::String)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Where h is the returned SnapshotHeader. This struct contains the following fields:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"mutable struct SnapshotHeader\n    npart::Vector{Int32}                # an array of particle numbers per type in this snapshot\n    massarr::Vector{Float64}            # an array of particle masses per type in this snapshot - if zero: MASS block present\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    flag_sfr::Int32                     # 1 if simulation was run with star formation, else 0\n    flag_feedback::Int32                # 1 if simulation was run with stellar feedback, else 0\n    nall::Vector{UInt32}                # total number of particles in the simulation\n    flag_cooling::Int32                 # 1 if simulation was run with cooling, else 0\n    num_files::Int32                    # number of snapshots over which the simulation is distributed\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_stellarage::Int32              # 1 if simulation was run with stellar age, else 0\n    flag_metals::Int32                  # 1 if simulation was run with metals, else 0\n    npartTotalHighWord::Vector{UInt32}  # weird\n    flag_entropy_instead_u::Int32       # 1 if snapshot U field contains entropy instead of internal energy, else 0\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32                 # 1 if the IC file contains an INFO block   \n    lpt_scalingfactor::Float32          # (almost) never used\n    fill::Vector{Int32}                 # the HEAD block needs to be filled with zeros to have a size of 256 bytes\nend","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"read_header is a wrapper around:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"h = head_to_obj(filename::String)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you want to read the header information into a dictionary you can use:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"h = head_to_dict(filename::String)","category":"page"},{"location":"file_infos/#Getting-the-block-names","page":"File Infos","title":"Getting the block names","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you are not sure which blocks are contained in the file you can have them printed to standard out with:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"blocks = print_blocks(filename)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This will return an array with the names of the blocks contained in the file, as well as printing them. If you only want the array, without printing call the function with the keyword argument verbose=false.","category":"page"},{"location":"file_infos/#Checking-if-a-block-is-present","page":"File Infos","title":"Checking if a block is present","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"To check wether a block is contained in the file you can use","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"is_present = block_present(filename, blockname)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"which will return true or false.","category":"page"},{"location":"file_infos/#Getting-the-block-positions-within-a-file","page":"File Infos","title":"Getting the block positions within a file","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you want to read in multiple blocks into individual variables you can speed the process up significantly by first getting the starting positions of the blocks with","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"block_pos = get_block_positions(filename)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"and passing the result to read_block.","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This returns a dictionary with the block names as keys and the starting position in bytes as an Integer:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"julia> block_pos[\"POS\"]\n1234567","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"and can be used with read_block by passing it to the keyword argument block_position:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"gas_pos = read_block(filename, \"POS\", parttype=0, block_position=block_pos[\"POS\"])\ngas_vel = read_block(filename, \"VEL\", parttype=0, block_position=block_pos[\"VEL\"])\ngas_rho = read_block(filename, \"RHO\", parttype=0, block_position=block_pos[\"RHO\"])","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"Please note that this only makes sense if you plan to read in multiple blocks. If the keyword argument is left out read_block will look for the block positions by itself.","category":"page"},{"location":"file_infos/#Reading-the-INFO-block","page":"File Infos","title":"Reading the INFO block","text":"","category":"section"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If you compiled Gadget with WRITE_INFO_BLOCK the snapshot contains a block INFO that holds information on the name, datatype, dimensionality and presence per particle for each block. This simplifies read-in greatly and is always recommended! You can obtain this block by using:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"info = read_info(filename)","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This returns an Array{InfoLine,1}, where InfoLine is:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"struct InfoLine\n    block_name::String              # name of the data block, e.g. \"POS\"\n    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double\n    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3\n    is_present::Vector{Int32}       # array of flags for which particle type this block is present,\n                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]\n                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\nend","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"You can use this as well to speed up read-in by passing the relevant Array entry to the keyword argument info in read_block:","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"gas_pos = read_block(filename, \"POS\", parttype=0, info=info[1])","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"This can of course be combined with reading the block positions for additional speedup.","category":"page"},{"location":"file_infos/","page":"File Infos","title":"File Infos","text":"If there is no INFO block in the simulation you need to construct the InfoLine struct yourself and pass it to read_block like in the previous example.","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager, so in the REPL type:","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add GadgetIO","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"read_snapshots/#Read-Snapshot-Data","page":"Reading Snapshots","title":"Read Snapshot Data","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"NOTE","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"From v0.4 and up snapshots are read in proper column-major order, as it should be for Julia. This means that position data for particle i neads be accessed as:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"x = pos[1,i]\ny = pos[2,i]\nz = pos[3,i]","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"GadgetIO.jl is specialized to read Gadget snapshots of Format 2. The structure of a Format 2 snapshot is as follows:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"8              # size of the blockname block (Int32)\nBLOCKNAME      # Blockname (4*Char)\n8+SIZE_BLOCK   # number of bytes to skip if block should not be read\n8              # end of blockname block\n\nSIZE_BLOCK     # size of the current block in bytes\n{...}          # content of the block ordered by particle type\nSIZE_BLOCK     # end of the current block","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"which repeats for every block.","category":"page"},{"location":"read_snapshots/#Filename","page":"Reading Snapshots","title":"Filename","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Before we get started, a short bit for clarification: In what follows we need to distinguish between filename and filebase. For small simulations the data is written to a single file. In that case you can simply supply an absolute, or relative path to the one snapshot file as filename.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For larger simulations the data may be distributed over multiple files, which again may be in individual snapshot directories. With the snapshots being distributed over multiple files you need to supply the base-name filebase. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the filebase is","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"filebase = \"path/to/your/snapshot/directories/snapdir_140/snap_140\"","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"In the relevant functions GadgetIO.jl will then automatically loop through the sub-snapshots which end in \".0\", \".1\", ... , \".N\".","category":"page"},{"location":"read_snapshots/#Reading-a-snapshot","page":"Reading Snapshots","title":"Reading a snapshot","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"There are multiple ways to read the data in the snapshot","category":"page"},{"location":"read_snapshots/#Full-snapshot","page":"Reading Snapshots","title":"Full snapshot","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to read a simulation snapshot into memory with GadgetIO.jl, it's as easy as this:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"    data = read_snap(filename)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with the header information in data[\"Header\"] and the blocks sorted by particle type.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"As an example, this is how you would access the positions of the gas particles:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"    data[\"Parttype0\"][\"POS\"]","category":"page"},{"location":"read_snapshots/#Specific-blocks","page":"Reading Snapshots","title":"Specific blocks","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function with a specified blockname and particle type like so:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"    pos = read_snap(filename, \"POS\", 0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return an array of the datatype of your simulation, usually Float32.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If the snapshot has no info block this will fail unfortunately.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"You can still read the specific block by supplying a hand-constructed InfoLine object:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"struct InfoLine\n    block_name::String              # name of the data block, e.g. \"POS\"\n    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double\n    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3\n    is_present::Vector{Int32}       # array of flags for which particle type this block is present,\n                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]\n                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"and passing that to the function read_block:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"pos = read_block(filename, \"POS\", info=pos_info, parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"where pos_info is an InfoLine object.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_snap is used mainly as a wrapper function to call read_block, in case you were wondering about the function name change.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"I will collect some example InfoLine objects in a later release to be able to read some common blocks even without an INFO block.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Since v0.5 read_snap and read_block also work if you pass them a file_base.","category":"page"},{"location":"read_snapshots/#Read-Subvolumes","page":"Reading Snapshots","title":"Read Subvolumes","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you only want to read a subvolume of the whole simulation you can do this in two ways. To get all particles within a subvolume of the simulation you can use the functions read_particles_in_box or read_particles_in_volume.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_in_box takes a box defined by a lower-left corner and an upper-right corner and reads all requested blocks and particles in that volume.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function read_particles_in_box( filename::String, blocks::Vector{String},\n                                corner_lowerleft,\n                                corner_upperright;\n                                parttype::Int=0,\n                                verbose::Bool=true,\n                                use_keys::Bool=true )\n\n            (...)\n\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"You can define an array of blocks you want to read, these will be read in parallel with simple multi-threading.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_in_volume is a simple wrapper around read_particles_in_box, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function read_particles_in_volume( filename::String, blocks::Vector{String},\n                                   center_pos::Vector{AbstractFloat},\n                                   radius::AbstractFloat;\n                                   parttype::Int=0,\n                                   verbose::Bool=true,\n                                   use_keys::Bool=true )\n\n            (...)\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For reading particles in more complex geometries you can use read_particles_in_geometry.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_in_geometry( filename::String, blocks::Vector{String},\n                            geometry::AbstractGadgetGeometry;\n                            parttype::Integer=0, verbose::Bool=true,\n                            use_keys::Bool=true)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"You can use built-in geometries like GadgetCube, GadgetSphere and GadgetCylinder.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to extend the functionality you can define your own geometry as","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"struct YourGeometry{T} <: AbstractGadgetGeometry\n    prop1::Vector{T}\n    prop2::Vector{T}\n    prop3::T\n    (...)\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"and define the functions get_geometry_box_corners and get_geometry_mask. get_geometry_box_corners has to return a Tuple of two vectors which define the lower left and upper right corner of a box that contains the geometry. get_geometry_mask has to return an array of indices for which pos is contained in the geometry.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"In all functions parttype defines the particle type to be read, as in the previous read functions and verbose gives console output. There are also multiple dispatch versions of all functions available that only take a single block as input and return an array with the values instead of a dictionary.","category":"page"},{"location":"read_snapshots/#Peano-Hilbert-key-based-reading","page":"Reading Snapshots","title":"Peano-Hilbert key based reading","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=true (which is the default case) it constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary. This is considerably faster than the brute-force attempt.","category":"page"},{"location":"read_snapshots/#Brute-Force-Reading","page":"Reading Snapshots","title":"Brute-Force Reading","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=false it reads all particles over all distributed files which are contained in the requested subvolume. This takes quite a lot longer than the key based reading, but sometimes it's the only option.","category":"page"},{"location":"read_snapshots/#Example","page":"Reading Snapshots","title":"Example","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Assuming pos_halo is the position of the center of mass of the halo and r_vir is its virial radius you read the data with","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"MASS\", \"RHO\", \"HSML\"]\n\ndata   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,\n                                  parttype=0,\n                                  verbose=true)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with the blocks as keys and containing the arrays for the particles.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"data[\"POS\"]  # array of positions\ndata[\"RHO\"]  # array of densities\n(...)","category":"page"},{"location":"read_snapshots/#Read-distributed-snapshotfiles","page":"Reading Snapshots","title":"Read distributed snapshotfiles","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to read multiple blocks in a simulation whose snapshots have been distributed over a number of sub-snapshots you can use read_blocks_over_all_files.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_blocks_over_all_files( snap_base::String, blocks::Array{String};\n                            filter_function::Union{Function, Nothing}=nothing, \n                            read_positions::Union{Dict, Nothing}=nothing, \n                            parttype::Integer=0, verbose::Bool=true )","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will read the specified blocks for all particles that pass the filter_function. This can be useful if you don't know where the region you are interested in is located and don't have enough memory to read in all particles. Alternatively you can also provide a Dict with read_positions as described in Read positions.","category":"page"},{"location":"read_snapshots/#Filter-functions","page":"Reading Snapshots","title":"Filter functions","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"The filter_function can be any function that takes a String input and returns an Array of Integers, or CartesianCoordinates. For example, if you want to filter all particles with a Mach number larger than 1:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function mach_gt_1(snap_file)\n    mach = read_snap(snap_file, \"MACH\", 0)\n    sel  = findall( mach .> 1.0 )\n    return sel\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Or if you want to trick the function into reading all particles after all:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"function pass_all(snap_file)\n    h = read_header(snap_file)\n    return collect(1:h.npart[1])\nend","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"As an example, to read positions, velocity and ID of all shocked particles from distributed snapshots use","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"ID\"]\ndata = read_blocks_over_all_files(snap_base, blocks, filter_function=mach_gt_1, parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"Just as a reminder from above you can read single blocks into an array by using read_snap and read_block:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"pos = read_block(snap_base, \"POS\", parttype=0)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This requiers GadgetIO.jl v0.5 though.","category":"page"},{"location":"read_snapshots/#Read-positions","page":"Reading Snapshots","title":"Read positions","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"To avoid having to filter all files each time you want to read a snapshot you can also split the steps. You can first filter the particles to find the positions of the particles within the data blocks with find_read_positions","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_positions = find_read_positions(snap_base, filter_function)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"and then save the result as a binary file with save_read_positions","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"save_read_positions(save_file, read_positions)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"where save_file is the filename you specified for storage.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This also works with an AbstractGadgetGeometry by calling find_read_positions with","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"find_read_positions( snap_base::String, geometry::AbstractGadgetGeometry;\n                     parttype::Integer=0,\n                     verbose::Bool=true )","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"To re-use the read_positions you can load them from file using load_read_positions","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_positions = load_read_positions(save_file)","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This can then be used to read any number of blocks with","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"blocks = [\"POS\", \"VEL\", \"ID\"]\ndata = read_blocks_over_all_files(snap_base, blocks, read_positions=read_positions, parttype=0)","category":"page"},{"location":"read_snapshots/#Reading-particles-by-referenced-ID","page":"Reading Snapshots","title":"Reading particles by referenced ID","text":"","category":"section"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"If you want to select specific particles to read from an array of IDs you can do this with read_particles_by_id:","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"read_particles_by_id(snap_base::String, selected_ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Union{Array{<:Real},Nothing}=nothing,\n                     r0::Real=0.0,\n                     use_keys::Bool=true )","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"snap_base defines the target snapshot, or the snapshot basename, selected_ids contains the list of IDs of the particles you want to read and blocks containes the blocknames of the blocks you want to read. If the simulation is too large to read the whole snapshot into memory you can give values for pos0 and r0 to read only a specific region with read_particles_in_volume. See Read Subvolumes for details on this.","category":"page"},{"location":"read_snapshots/","page":"Reading Snapshots","title":"Reading Snapshots","text":"This will return a dictionary with all requested blocks.","category":"page"},{"location":"write_data/#Write-Data","page":"Writing Data","title":"Write Data","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"GadgetIO.jl can write snapshots that can be used as initial conditions.","category":"page"},{"location":"write_data/#Format-2","page":"Writing Data","title":"Format 2","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"The safest way to write snapshots is in Format 2. Simply set up your header object and the arrays you want to write in the correct data format. For the header this is the struct Header and for data its usually Array{Float32,2}. You can then write an initial condition file by writing the header and the individual data blocks.","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header)\nwrite_block(filename,  pos, \"POS\")\nwrite_block(filename,  vel, \"VEL\")\nwrite_block(filename,  id,  \"ID\")","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Please note that you have to combine the arrays for individual particles in the correct order.","category":"page"},{"location":"write_data/#Format-1","page":"Writing Data","title":"Format 1","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Writing in format 1 works the same as above, but you need different function values. Also you need to make sure the blocks are in the order gadget expects them to be!","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header, snap_format=1)\nwrite_block(filename,  pos,    snap_format=1)\nwrite_block(filename,  vel,    snap_format=1)\nwrite_block(filename,  id,     snap_format=1)","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\",\n          \"install.md\",\n          \"file_infos.md\",\n          \"read_snapshots.md\", \n          \"read_subfind.md\",\n          \"write_data.md\",\n          \"api.md\" \n        ]\nDepth = 3","category":"page"}]
}
