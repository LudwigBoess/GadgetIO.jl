var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.block_present","page":"API reference","title":"GadgetIO.block_present","text":"block_present(filename::String, blockname::String, blocks::Vector{String}=[\"\"])\n\nChecks if a given block is present in the snapshot file, or in the supplied blocks Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.filter_subfind","page":"API reference","title":"GadgetIO.filter_subfind","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function [, nfiles::Integer=1])\n\nSelects entries in subfind block that fulfill the 'filter_funcion' requirements and returns a 'SubfindFilter' object.\n\nExamples\n\njulia> find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\nfind_mass_gt_1e15 (generic function with 1 method)\njulia> filtered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_most_massive_halo","page":"API reference","title":"GadgetIO.find_most_massive_halo","text":"find_most_massive_halo(filebase::String [, nfiles::Int=1])\n\nReads the selected file and its subfiles and returns position, virial radius and a SubfindID object that contains the subfile which contains the most massive halo and the position in the block.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.head_to_dict-Tuple{String}","page":"API reference","title":"GadgetIO.head_to_dict","text":"head_to_dict(filename::String)\n\nReturns the header of a snapshot as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_obj-Tuple{Any}","page":"API reference","title":"GadgetIO.head_to_obj","text":"head_to_obj(filename::String)\n\nReturns the header of a snapshot as a Header object.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.print_blocks-Tuple{String}","page":"API reference","title":"GadgetIO.print_blocks","text":"print_blocks(filename::String; verbose::Bool=true)\n\nReads the block names of blocks in a snapshot and returns them in an array. Outputs them to console if verbose=true\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_by_name-Tuple{String,String}","page":"API reference","title":"GadgetIO.read_block_by_name","text":"read_block_by_name(filename::String, blockname::String;\n                            info::Info_Line=Info_Line(),\n                            parttype::Integer=-1)\n\nReads a block in a snapshot with given name. Names are case sensitive.\n\nExamples\n\njulia> pos_info = Info_Line(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\n[...]\njulia> gas_pos = read_block_by_name(filename, \"POS\", info=pos_info, parttype=0)\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_header","text":"read_header(filename::String)\n\nReads the header of a snapshot and returns a Header object.\n\nSee also: head_to_obj\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info-Tuple{String}","page":"API reference","title":"GadgetIO.read_info","text":"read_info(filename; verbose::Bool=false)\n\nReads the info block of a snapshot and returns the information in an array of Info_Line types. If verbose=true the blocknames are also printed to console.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String,Array{String,1},Any,Any}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      corner_lowerleft, corner_upperright;\n                      parttype::Integer=0, verbose::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String,String,Any,Any}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::String,\n                      corner_lowerleft, corner_upperright;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_box but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String,Array{String,1},Any,Any}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nReads all particles within a box encapsulating a volume defined by center position and radius for a given particle type. Returns a dictionary with all requested blocks.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String,String,Any,Any}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::String,\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_volume but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_volume\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_snap","page":"API reference","title":"GadgetIO.read_snap","text":"read_snap(filename::String [, blockname::String=\"\", parttype::Integer=-1] )\n\nWrapper function to read snapshot in various ways: filename only: returns the entire snapshot as a dictionary. blockname: Returns only that block. If parttype specified only for that particle type.\n\nExamples\n\njulia> gas_pos = read_block_by_name(filename, \"POS\", 0)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.snap_to_dict","page":"API reference","title":"GadgetIO.snap_to_dict","text":"snap_to_dict(filename::String, try_info::Bool=true)\n\nReads whole snapshot into memory and returns a dictionary sorted by particle type and block names. Be cautious with large snapshots!\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_block","page":"API reference","title":"GadgetIO.write_block","text":"write_block(f::IOStream, data,\n            blockname::String=\"\";\n            snap_format::Integer=2)\n\nWrite data to a block to an opened file f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_header-Tuple{IOStream,Header}","page":"API reference","title":"GadgetIO.write_header","text":"write_header(f::IOStream, h::Header; snap_format::Integer=2)\n\nWrites the header block to an opened file f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#GadgetIO.Header","page":"API reference","title":"GadgetIO.Header","text":"mutable struct Header( [ **Fields ])\n\nContains the data of the HEAD block of a Gadget snapshot.\n\nFields\n\n| Name                                 | Meaning                                                                                | |: ––––––––––––––––––|:–––––––––––––––––––––––––––––––––––––––––––-| | npart::Vector{Int32}               | an array of particle numbers per type in this snapshot                                 | | massarr::Vector{Float64}           | an array of particle masses per type in this snapshot - if zero: MASS block present    | | time::Float64                      | time / scale factor of the simulation                                                  | | z::Float64                         | redshift of the simulation                                                             | | flag_sfr::Int32                    | 1 if simulation was run with star formation, else 0                                    | | flag_feedback::Int32               | 1 if simulation was run with stellar feedback, else 0                                  | | nall::Vector{UInt32}               | total number of particles in the simulation                                            | | flag_cooling::Int32                | 1 if simulation was run with cooling, else 0                                           | | num_files::Int32                   | number of snapshots over which the simulation is distributed                           | | omega_0::Float64                   | Omega matter                                                                           | | boxsize::Float64                   | total size of the simulation box                                                       | | omega_l::Float64                   | Omega dark enery                                                                       | | h0::Float64                        | little h                                                                               | | flag_stellarage::Int32             | 1 if simulation was run with stellar age, else 0                                       | | flag_metals::Int32                 | 1 if simulation was run with metals, else 0                                            | | npartTotalHighWord::Vector{UInt32} | weird                                                                                  | | flag_entropy_instead_u::Int32      | 1 if snapshot U field contains entropy instead of internal energy, else 0              | | flag_doubleprecision::Int32        | 1 if snapshot is in double precision, else 0                                           | | flag_ic_info::Int32                | 1 if initial snapshot file contains an info block, else 0                              | | lpt_scalingfactor::Float32         | factor to use second order ic generation                                               | | fill::Vector{Int32}                | the HEAD block needs to be filled with zeros to have a size of 256 bytes               |\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.Info_Line","page":"API reference","title":"GadgetIO.Info_Line","text":"mutable struct Info_Line([  block_name=\"\", data_type=Float32, n_dim=Int32(0),\n                            is_present=zeros(Int32, 6) ])\n\nContains the data of a single entry in the INFO block of a Gadget snapshot.\n\nFields\n\n| Name                                 | Meaning                                                                                | |: ––––––––––––––––––|:–––––––––––––––––––––––––––––––––––––––––––-| | block_name::String                 | name of the data block, e.g. \"POS\"                                                     | | data_type::DataType                | datatype of the block, e.g. Float32 for single precision, Float64 for double           | | n_dim::Int32                       | number of dimensions of the block, usually 1 or 3                                      | | is_present::Vector{Int32}          | array of flags for which particle type this block is present,                          | |                                      |  e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ],                                                 | |                                      |  or gas + BHs: [ 1, 0, 0, 0, 0, 1 ]                                                    |\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.find_files_for_keys_old-Tuple{String,Integer,Array{UInt64,1}}","page":"API reference","title":"GadgetIO.find_files_for_keys_old","text":"This should be fixed! It's A LOT faster than the simpler version!\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions","text":"get_block_positions(filename::String)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_int_pos-Tuple{AbstractFloat,Float64,Float64}","page":"API reference","title":"GadgetIO.get_int_pos","text":"Helper function for Peano Hilbert stuff\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager, so in the REPL type:","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add GadgetIO","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"write_data/#Write-Data","page":"Writing Data","title":"Write Data","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"GadgetIO.jl can write snapshots that can be used as initial conditions.","category":"page"},{"location":"write_data/#Format-2","page":"Writing Data","title":"Format 2","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"The safest way to write snapshots is in Format 2. Simply set up your header object and the arrays you want to write in the correct data format. For the header this is the struct Header and for data its usually Array{Float32,2}. You can then write an initial condition file by writing the header and the individual data blocks.","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header)\nwrite_block(filename,  pos, \"POS\")\nwrite_block(filename,  vel, \"VEL\")\nwrite_block(filename,  id,  \"ID\")","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Please note that you have to combine the arrays for individual particles in the correct order.","category":"page"},{"location":"write_data/#Format-1","page":"Writing Data","title":"Format 1","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Writing in format 1 works the same as above, but you need different function values. Also you need to make sure the blocks are in the order gadget expects them to be!","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header, snap_format=1)\nwrite_block(filename,  pos,    snap_format=1)\nwrite_block(filename,  vel,    snap_format=1)\nwrite_block(filename,  id,     snap_format=1)","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"read_data.md\", \n          \"write_data.md\",\n          \"api.md\"]\nDepth = 3","category":"page"},{"location":"read_data/#Read-Snapshot-Data","page":"Reading Data","title":"Read Snapshot Data","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"read_data/#Reading-the-header","page":"Reading Data","title":"Reading the header","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Reading the header block of the simulation can be done by using:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = read_header(filename::String)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Where h is the returned Header object:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"mutable struct Header\n    npart::Vector{Int32}                # an array of particle numbers per type in this snapshot\n    massarr::Vector{Float64}            # an array of particle masses per type in this snapshot - if zero: MASS block present\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    flag_sfr::Int32                     # 1 if simulation was run with star formation, else 0\n    flag_feedback::Int32                # 1 if simulation was run with stellar feedback, else 0\n    nall::Vector{UInt32}                # total number of particles in the simulation\n    flag_cooling::Int32                 # 1 if simulation was run with cooling, else 0\n    num_files::Int32                    # number of snapshots over which the simulation is distributed\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_stellarage::Int32              # 1 if simulation was run with stellar age, else 0\n    flag_metals::Int32                  # 1 if simulation was run with metals, else 0\n    npartTotalHighWord::Vector{UInt32}  # weird\n    flag_entropy_instead_u::Int32       # 1 if snapshot U field contains entropy instead of internal energy, else 0\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32                 # 1 if the IC file contains an INFO block   \n    lpt_scalingfactor::Float32          # (almost) never used\n    fill::Vector{Int32}                 # the HEAD block needs to be filled with zeros to have a size of 256 bytes\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This is equivalent to:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = head_to_obj(filename::String)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read the header information into a dictionary you can use:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = head_to_dict(filename::String)","category":"page"},{"location":"read_data/#Reading-a-snapshot","page":"Reading Data","title":"Reading a snapshot","text":"","category":"section"},{"location":"read_data/#Full-snapshot","page":"Reading Data","title":"Full snapshot","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read a simulation snapshot into memory with GadgetIO.jl, it's as easy as this:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    data = read_snap(filename)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return a dictionary with the header information in data[\"Header\"] and the blocks sorted by particle type.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"As an example, this is how you would access the positions of the gas particles:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    data[\"Parttype0\"][\"POS\"]","category":"page"},{"location":"read_data/#Specific-blocks","page":"Reading Data","title":"Specific blocks","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Reading specific blocks only works with Format 2 at the moment.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function with a specified blockname and particle type like so:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    pos = read_snap(filename, \"POS\", 0)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an array of the datatype of your simulation, usually Float32.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If the snapshot has no info block this will fail unfortunately.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can still read the specific block by supplying a hand-constructed Info_Line object:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"mutable struct Info_Line\n    block_name::String              # name of the data block, e.g. \"POS\"\n    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double\n    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3\n    is_present::Vector{Int32}       # array of flags for which particle type this block is present,\n                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]\n                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"and passing that to the function read_block_by_name:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    pos = read_block_by_name(filename, \"POS\", info=pos_info, parttype=0)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"where pos_info is an Info_Line object.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_snap is used mainly as a wrapper function to call read_block_by_name, in case you were wondering about the function name change.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"I will collect some example Info_Line objects in a later release to be able to read some common blocks even without an info block.","category":"page"},{"location":"read_data/#Getting-snapshot-infos","page":"Reading Data","title":"Getting snapshot infos","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you have a Format 2 snapshot and just want to know what blocks the snapshot contains you can use the function","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    print_blocks(filename)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"to get an output of all block names.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If your simulation contains an INFO block you can read the info lines into Info_Line object like so:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    info = read_info(filename, verbose=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an Array of Info_Line objects. The optional keyword verbose additionally gives the same functionality as print_blocks and prints the names to the console.","category":"page"},{"location":"read_data/#Large-Simulations","page":"Reading Data","title":"Large Simulations","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"To get all particles within a subvolume of the simulation you can use the functions read_particles_in_box or read_particles_in_volume.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_in_box takes a box defined by a lower-left corner and an upper-right corner, constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function read_particles_in_box(filename::String, blocks::Vector{String},\n                               corner_lowerleft,\n                               corner_upperright;\n                               parttype::Int=0,\n                               verbose::Bool=true)\n\n            (...)\n\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can define an array of blocks you want to read, these will be read in parallel with simple multi-threading.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_in_volume is a simple wrapper around read_particles_in_box, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function read_particles_in_volume(filename::String, blocks::Vector{String},\n                                  center_pos::Vector{AbstractFloat},\n                                  radius::AbstractFloat;\n                                  parttype::Int=0,\n                                  verbose::Bool=true)\n\n            (...)\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"In both functions parttype defines the particle type to be read, as in the previous read functions and verbose gives console output.","category":"page"},{"location":"read_data/#Filename","page":"Reading Data","title":"Filename","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"With the snapshots being distributed over multiple filenames you need to be careful with that keyword. In this case filename refers to the base-name. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the filename is","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"filename = \"path/to/your/snapshot/directories/snapdir_140/snap_140\"","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"GadgetIO will then automatically loop through the sub-snapshots which end in \".0\", \".1\", ... , \".N\".","category":"page"},{"location":"read_data/#Example","page":"Reading Data","title":"Example","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Assuming pos_halo is the position of the center of mass of the halo and r_vir is its virial radius you read the data with","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"blocks = [\"POS\", \"VEL\", \"MASS\", \"RHO\", \"HSML\"]\n\ndata   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,\n                                  parttype=0,\n                                  verbose=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return a dictionary with the blocks as keys and containing the arrays for the particles.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"data[\"POS\"]  # array of positions\ndata[\"RHO\"]  # array of densities\n(...)","category":"page"},{"location":"read_data/#Upcoming","page":"Reading Data","title":"Upcoming","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"One of the next steps will be to finish the reading function for particles in a specific halo. Since this is a bit of a pain I postponed this to when I will actually need it.","category":"page"},{"location":"read_data/#Read-Subfind-Data","page":"Reading Data","title":"Read Subfind Data","text":"","category":"section"},{"location":"read_data/#Reading-the-header-2","page":"Reading Data","title":"Reading the header","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Similarly to the normal snapshot you can read the header of the subfind output into a SubfindHeader object","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"struct SubfindHeader\n    nhalos::Int32                       # number of halos in the output file\n    nsubhalos::Int32                    # number of subhalos in the output file\n    nfof::Int32                         # number of particles in the FoF\n    ngroups::Int32                      # number of large groups in the output file\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    tothalos::UInt32                    # total number of halos over all output files\n    totsubhalos::UInt32                 # total number of subhalos over all output files\n    totfof::UInt32                      # total number of particles in the FoF\n    totgroups::UInt32                   # total number of large groups over all output files\n    num_colors::Int32                   # number of colors\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"using","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"h = read_subfind_header(filename::String)","category":"page"},{"location":"read_data/#Reading-the-subfind-files","page":"Reading Data","title":"Reading the subfind files","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you compiled Gadget with WRITE_SUB_IN_SNAP_FORMAT you can read the subfind output like you would a normal snapshot, with any of the above methods. For convenience you can also use a helper function provided by GadgetIO. Since each of the blocks is only relevant for either halos, subhalos, Fof or large groups you don't need to define a particly type, aka halo type in this case.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"So in order to read the virial radius of the halos in a file you can simply use","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"R_vir = read_subfind(filename, \"RVIR\")","category":"page"},{"location":"read_data/#Filtered-readin","page":"Reading Data","title":"Filtered readin","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read specific halos from the subfind output you can use the function","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function, nfiles::Integer=1)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an array of SubfindIDs ","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"struct SubfindID\n    file::Int64\n    id::Int64\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can use this to read specific files with read_subfind and select the array entry via the id field.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"The filter_function argument takes any function that takes one input argument and returns true if the requirement is fulfilled, or false if not.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"So to find e.g. all halos with a virial mass largert than 10^15 M_odot you can use","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\n\nfiltered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will search all subfind files in the directory and check if they fulfill the filter. Since halos in subfind files are sorted by mass you can also supply a number of files to search with the argument nfiles. That way, if you are looking for a very massive halo you can constrian the reading and filtering to only the first N files to save time.","category":"page"}]
}
