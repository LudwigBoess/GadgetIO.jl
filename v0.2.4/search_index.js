var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.block_present","page":"API reference","title":"GadgetIO.block_present","text":"block_present(filename::String, blockname::String, blocks::Vector{String}=[\"\"])\n\nChecks if a given block is present in the snapshot file, or in the supplied blocks Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.filter_subfind","page":"API reference","title":"GadgetIO.filter_subfind","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function [, nfiles::Integer=1])\n\nSelects entries in subfind block that fulfill the 'filter_funcion' requirements and returns a 'SubfindFilter' object.\n\nExamples\n\njulia> find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\nfind_mass_gt_1e15 (generic function with 1 method)\njulia> filtered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.find_most_massive_halo","page":"API reference","title":"GadgetIO.find_most_massive_halo","text":"find_most_massive_halo(filebase::String [, nfiles::Int=1])\n\nReads the selected file and its subfiles and returns position, virial radius and a HaloID object that contains the subfile which contains the most massive halo and the position in the block.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.get_index_list-Tuple{Array{var\"#s55\",N} where N where var\"#s55\"<:Integer,Array{var\"#s54\",N} where N where var\"#s54\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list","text":"get_index_list(idarr1::Array{<:Integer}, idarr2::Array{<:Integer})\n\nGet positions in idarr2 where idarr2 matches idarr1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_npart_to_read-Tuple{String,Function}","page":"API reference","title":"GadgetIO.get_npart_to_read","text":"get_npart_to_read( snap_base::String, filter_function::Function)\n\nFinds the number of particles in a snapshot directory that pass the filter_function.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_dict-Tuple{String}","page":"API reference","title":"GadgetIO.head_to_dict","text":"head_to_dict(filename::String)\n\nReturns the header of a snapshot as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.head_to_obj-Tuple{Any}","page":"API reference","title":"GadgetIO.head_to_obj","text":"head_to_obj(filename::String)\n\nReturns the header of a snapshot as a Header object.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.print_blocks-Tuple{String}","page":"API reference","title":"GadgetIO.print_blocks","text":"print_blocks(filename::String; verbose::Bool=true)\n\nReads the block names of blocks in a snapshot and returns them in an array. Outputs them to console if verbose=true\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_by_name-Tuple{String,String}","page":"API reference","title":"GadgetIO.read_block_by_name","text":"read_block_by_name(filename::String, blockname::String;\n                            info::Info_Line=Info_Line(),\n                            parttype::Integer=-1)\n\nReads a block in a snapshot with given name. Names are case sensitive.\n\nExamples\n\njulia> pos_info = Info_Line(\"POS\", Float32, 1, [1, 1, 1, 1, 1, 1])\n[...]\njulia> gas_pos = read_block_by_name(filename, \"POS\", info=pos_info, parttype=0)\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_blocks_over_all_files-Tuple{String,Array{String,N} where N,Function}","page":"API reference","title":"GadgetIO.read_blocks_over_all_files","text":"read_blocks_over_all_files( snap_base::String, blocks::Array{String}, filter_function::Function; \n                            N_to_read::Integer=-1, parttype::Integer=0 )\n\nReads the specified blocks from all distributed files where particles pass the filter_function. Per default the functions checks the number of particles that pass the filter.  If that number is known in advance it can be given via the N_to_read keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_header","text":"read_header(filename::String)\n\nReads the header of a snapshot and returns a Header object.\n\nSee also: head_to_obj\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_ids_in_halo-Tuple{String,HaloID}","page":"API reference","title":"GadgetIO.read_ids_in_halo","text":"read_ids_in_halo( sub_base::String, halo::HaloID; \n                  halo_type::Integer=1, verbose::Bool=true)\n\nReads the IDs of all particles contained in a halo.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_info-Tuple{String}","page":"API reference","title":"GadgetIO.read_info","text":"read_info(filename; verbose::Bool=false)\n\nReads the info block of a snapshot and returns the information in an array of Info_Line types. If verbose=true the blocknames are also printed to console.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String,Array{var\"#s49\",N} where N where var\"#s49\"<:Integer,Array{String,N} where N}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns all requested blocks as entries in a Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id-Tuple{String,Array{var\"#s53\",N} where N where var\"#s53\"<:Integer,String}","page":"API reference","title":"GadgetIO.read_particles_by_id","text":"read_particles_by_id(snap_base::String, ids::Array{<:Integer}, \n                     block::String; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0)\n\nReads particles filtered by the provided IDs. Returns the requested block as an Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String,Array{String,1},Array{var\"#s53\",N} where N where var\"#s53\"<:Real,Array{var\"#s52\",N} where N where var\"#s52\"<:Real}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type based on peano hilbert key reading. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box-Tuple{String,String,Array{var\"#s53\",N} where N where var\"#s53\"<:Real,Array{var\"#s52\",N} where N where var\"#s52\"<:Real}","page":"API reference","title":"GadgetIO.read_particles_in_box","text":"read_particles_in_box(filename::String, blocks::String,\n                      corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nLike read_particles_in_box but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String,Array{String,N} where N,String,HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo(snap_base::String, blocks::Array{String},\n                            sub_base::String, halo::HaloID; \n                            rad_scale::Real=1.0, halo_type::Integer=1,\n                            parttype::Integer=0, verbose::Bool=true)\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. Returns a Dict with each of the blocks as entries.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_halo-Tuple{String,String,String,HaloID}","page":"API reference","title":"GadgetIO.read_particles_in_halo","text":"read_particles_in_halo( snap_base::String, block::String,\n                        sub_base::String, halo::HaloID; \n                        rad_scale::Real=1.0, halo_type::Integer=1,\n                        parttype::Integer=0, verbose::Bool=true )\n\nReads all particles of type parttype that are contained in a halo defined by its HaloID. Returns an Array with the requested block.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String,Array{String,1},Array{var\"#s56\",N} where N where var\"#s56\"<:Real,Real}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::Vector{String},\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true,\n                      use_keys::Bool=true)\n\nReads all particles within a box encapsulating a volume defined by center position and radius for a given particle type. Returns a dictionary with all requested blocks.\n\nSee also: read_particles_in_box\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_volume-Tuple{String,String,Any,Any}","page":"API reference","title":"GadgetIO.read_particles_in_volume","text":"read_particles_in_box(filename::String, blocks::String,\n                      center_pos, radius;\n                      parttype::Integer=0, verbose::Bool=true)\n\nLike read_particles_in_volume but for a single block. Returns the block as an array.\n\nSee also: read_particles_in_volume\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_snap","page":"API reference","title":"GadgetIO.read_snap","text":"read_snap(filename::String [, blockname::String=\"\", parttype::Integer=-1] )\n\nWrapper function to read snapshot in various ways: filename only: returns the entire snapshot as a dictionary. blockname: Returns only that block. If parttype specified only for that particle type.\n\nExamples\n\njulia> gas_pos = read_block_by_name(filename, \"POS\", 0)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.read_subfind-Tuple{String,String}","page":"API reference","title":"GadgetIO.read_subfind","text":"read_subfind(filename::String, blockname::String)\n\nReads a block of a subfind file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_subfind_header-Tuple{String}","page":"API reference","title":"GadgetIO.read_subfind_header","text":"read_subfind_header(filename::String)\n\nReads the header of a subfind file into a SubfindHeader struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.snap_to_dict","page":"API reference","title":"GadgetIO.snap_to_dict","text":"snap_to_dict(filename::String, try_info::Bool=true)\n\nReads whole snapshot into memory and returns a dictionary sorted by particle type and block names. Be cautious with large snapshots!\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_block","page":"API reference","title":"GadgetIO.write_block","text":"write_block(f::IOStream, data,\n            blockname::String=\"\";\n            snap_format::Integer=2)\n\nWrite data to a block to an opened file f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GadgetIO.write_header-Tuple{IOStream,Header}","page":"API reference","title":"GadgetIO.write_header","text":"write_header(f::IOStream, h::Header; snap_format::Integer=2)\n\nWrites the header block to an opened file f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#GadgetIO.HaloID","page":"API reference","title":"GadgetIO.HaloID","text":"struct HaloID\n    file::Int64\n    id::Int64\nend\n\nStores the subfile that contains the halo in file and the position in the block in id.\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.Header","page":"API reference","title":"GadgetIO.Header","text":"mutable struct Header( [ **Fields ])\n\nContains the data of the HEAD block of a Gadget snapshot.\n\nFields\n\nName Meaning\nnpart::Vector{Int32} an array of particle numbers per type in this snapshot\nmassarr::Vector{Float64} an array of particle masses per type in this snapshot - if zero: MASS block present\ntime::Float64 time / scale factor of the simulation\nz::Float64 redshift of the simulation\nflag_sfr::Int32 1 if simulation was run with star formation, else 0\nflag_feedback::Int32 1 if simulation was run with stellar feedback, else 0\nnall::Vector{UInt32} total number of particles in the simulation\nflag_cooling::Int32 1 if simulation was run with cooling, else 0\nnum_files::Int32 number of snapshots over which the simulation is distributed\nomega_0::Float64 Omega matter\nboxsize::Float64 total size of the simulation box\nomega_l::Float64 Omega dark enery\nh0::Float64 little h\nflag_stellarage::Int32 1 if simulation was run with stellar age, else 0\nflag_metals::Int32 1 if simulation was run with metals, else 0\nnpartTotalHighWord::Vector{UInt32} weird\nflag_entropy_instead_u::Int32 1 if snapshot U field contains entropy instead of internal energy, else 0\nflag_doubleprecision::Int32 1 if snapshot is in double precision, else 0\nflag_ic_info::Int32 1 if initial snapshot file contains an info block, else 0\nlpt_scalingfactor::Float32 factor to use second order ic generation\nfill::Vector{Int32} the HEAD block needs to be filled with zeros to have a size of 256 bytes\n\n\n\n\n\n","category":"type"},{"location":"api/#GadgetIO.Info_Line","page":"API reference","title":"GadgetIO.Info_Line","text":"mutable struct Info_Line([  block_name=\"\", data_type=Float32, n_dim=Int32(0),\n                            is_present=zeros(Int32, 6) ])\n\nContains the data of a single entry in the INFO block of a Gadget snapshot.\n\nFields\n\nName Meaning\nblock_name::String name of the data block, e.g. \"POS\"\ndata_type::DataType datatype of the block, e.g. Float32 for single precision, Float64 for double\nn_dim::Int32 number of dimensions of the block, usually 1 or 3\nis_present::Vector{Int32} array of flags for which particle type this block is present,\n e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ],\n or gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#GadgetIO.allocate_data_dict-Tuple{Array{String,N} where N,Integer,Array{Info_Line,N} where N,Bool}","page":"API reference","title":"GadgetIO.allocate_data_dict","text":"allocate_data_dict( blocks::Array{String}, N_to_read::Integer, \n                    snap_info::Array{Info_Line}, no_mass_block::Bool )\n\nHelper function to allocate the data Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.check_blocks-Tuple{String,Array{String,N} where N}","page":"API reference","title":"GadgetIO.check_blocks","text":"check_blocks(snap_base::String, blocks::Array{String})\n\nCheck if all requested blocks are present.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.filter_by_ids-Tuple{Array{var\"#s447\",N} where N where var\"#s447\"<:Integer,Array{var\"#s57\",N} where N where var\"#s57\"<:Integer}","page":"API reference","title":"GadgetIO.filter_by_ids","text":"filter_by_ids( selected_ids::Array{<:Integer}, ids::Array{<:Integer})\n\nChecks for matching IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_files_for_keys-Tuple{String,Integer,Array{var\"#s55\",1} where var\"#s55\"<:Integer}","page":"API reference","title":"GadgetIO.find_files_for_keys","text":"find_files_for_keys(filebase::String, nfiles::Integer, keylist::Vector{<:Integer})\n\nSelects the files in which the particles associated with the given Peano-Hilbert keys are stored.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_files_for_keys_AR-Tuple{String,Integer,Array{var\"#s54\",1} where var\"#s54\"<:Integer}","page":"API reference","title":"GadgetIO.find_files_for_keys_AR","text":"find_files_for_keys_AR(filebase::String, nfiles::Integer, keylist::Vector{<:Integer})\n\nSelects the files in which the particles associated with the given Peano-Hilbert keys are stored. Version of Antonio. (Slower than Klaus' version!)\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.find_read_positions-Tuple{Array{var\"#s50\",N} where N where var\"#s50\"<:Integer,String,Array{String,N} where N,Integer,Array{var\"#s49\",N} where N where var\"#s49\"<:Integer,Array{Info_Line,N} where N,Bool}","page":"API reference","title":"GadgetIO.find_read_positions","text":"find_read_positions(files::Array{<:Integer}, filebase::String, \n                         blocks::Array{String}, parttype::Integer)\n\nHelper function to get positions and length of particle blocks in files.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_block_positions-Tuple{String}","page":"API reference","title":"GadgetIO.get_block_positions","text":"get_block_positions(filename::String)\n\nReturns a dictionary with the starting positions of all blocks in a snapshot in bits.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_index_list_dict-Tuple{Array{var\"#s52\",N} where N where var\"#s52\"<:Integer,Array{var\"#s51\",N} where N where var\"#s51\"<:Integer}","page":"API reference","title":"GadgetIO.get_index_list_dict","text":"get_index_list_dict(keylist::Array{<:Integer}, keys_in_file::Array{<:Integer})\n\nGet positions in keys_in_file where keys_in_file matches keylist. Uses a Dict for lookup -> slower than the normal version.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_int_pos-Tuple{Real,Real,Real}","page":"API reference","title":"GadgetIO.get_int_pos","text":"get_int_pos(pos::Real, domain_corner::Real, domain_fac::Real )\n\nComputes the integer position along the PH line.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.get_keylist-Tuple{GadgetIO.KeyHeader,Array{var\"#s51\",N} where N where var\"#s51\"<:Real,Array{var\"#s50\",N} where N where var\"#s50\"<:Real}","page":"API reference","title":"GadgetIO.get_keylist","text":"get_keylist(h_key::KeyHeader, x0::Array{<:Real}, x1::Array{<:Real})\n\nGet all Peano-Hilbert keys for domain defined by the corner points x0 and x1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.join_blocks-Tuple{Any,Any}","page":"API reference","title":"GadgetIO.join_blocks","text":"function joinblocks(offsetkey, partperkey)\n\nJoins neigboring blocks to simplify read-in.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.peano_hilbert_key-NTuple{4,Integer}","page":"API reference","title":"GadgetIO.peano_hilbert_key","text":"peano_hilbert_key(bits::Integer, x::Integer, y::Integer, z::Integer)\n\nComputes a Peano-Hilbert key for an integer triplet (x,y,z) with x,y,z in the range between 0 and 2^bits-1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_block_with_offset!-Tuple{Any,Integer,String,Integer,Info_Line,Integer,Array{var\"#s25\",N} where N where var\"#s25\"<:Integer,Array{var\"#s24\",N} where N where var\"#s24\"<:Integer}","page":"API reference","title":"GadgetIO.read_block_with_offset!","text":"read_block_with_offset!(data, n_read::Integer, filename::String, pos0::Integer, info::Info_Line,\n                            offset::Integer, offset_key::Array{<:Integer}, \n                            part_per_key::Array{<:Integer} )\n\nRead part of a block to pre-allocated array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_key_index-Tuple{String}","page":"API reference","title":"GadgetIO.read_key_index","text":"read_key_index(file_key_index::String)\n\nReads the .key.index file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_keyheader-Tuple{String}","page":"API reference","title":"GadgetIO.read_keyheader","text":"read_keyheader(filename::String)\n\nReads the header of a .key file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_by_id_single_file-Tuple{String,Array{var\"#s56\",N} where N where var\"#s56\"<:Integer,Array{String,N} where N,Integer}","page":"API reference","title":"GadgetIO.read_particles_by_id_single_file","text":"read_particles_by_id_single_file(snap_file::String, halo_ids::Array{<:Integer}, \n                                      blocks::Array{String}, parttype::Integer)\n\nHelper function to read the matching IDs of particles in one whole file.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_particles_in_box_peano-Tuple{String,Array{String,1},Array{var\"#s23\",N} where N where var\"#s23\"<:Real,Array{var\"#s22\",N} where N where var\"#s22\"<:Real}","page":"API reference","title":"GadgetIO.read_particles_in_box_peano","text":"read_particles_in_box_peano(filename::String, blocks::Vector{String},\n                            corner_lowerleft::Array{<:Real}, corner_upperright::Array{<:Real};\n                            parttype::Integer=0, verbose::Bool=true)\n\nReads all particles within a box defined by a lower left and upper right corner for a given particle type based on peano hilbert key reading. Returns a dictionary with all requested blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.read_pids-Tuple{String,Integer,Integer}","page":"API reference","title":"GadgetIO.read_pids","text":"read_pids(sub_base::String, offset::Integer, N_ids::Integer)\n\nReads the PID block in the subfind output.\n\n\n\n\n\n","category":"method"},{"location":"api/#GadgetIO.select_file-Tuple{String,Integer}","page":"API reference","title":"GadgetIO.select_file","text":"select_file(filebase::String, filenum::Integer)\n\nChecks if the requested files exists and returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GadgetIO]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"api/#GadgetIO.KeyHeader","page":"API reference","title":"GadgetIO.KeyHeader","text":"struct KeyHeader\n\nHelper struct to store header information of .key files.\n\nFields\n\nName Meaning\nnkeys_file Number of keys in this .key file\ndomain_corners Corners of the domains defined by these keys\ndomain_fac Factor needed for reconstructung int positions\nbits Size of PH keys it bits\nnkeys_total Total number of keys in all files\nnkeys_total_highword Total number of keys in all files\n\n\n\n\n\n","category":"type"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager, so in the REPL type:","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add GadgetIO","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"Now you should be good to go!","category":"page"},{"location":"write_data/#Write-Data","page":"Writing Data","title":"Write Data","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"GadgetIO.jl can write snapshots that can be used as initial conditions.","category":"page"},{"location":"write_data/#Format-2","page":"Writing Data","title":"Format 2","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"The safest way to write snapshots is in Format 2. Simply set up your header object and the arrays you want to write in the correct data format. For the header this is the struct Header and for data its usually Array{Float32,2}. You can then write an initial condition file by writing the header and the individual data blocks.","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header)\nwrite_block(filename,  pos, \"POS\")\nwrite_block(filename,  vel, \"VEL\")\nwrite_block(filename,  id,  \"ID\")","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Please note that you have to combine the arrays for individual particles in the correct order.","category":"page"},{"location":"write_data/#Format-1","page":"Writing Data","title":"Format 1","text":"","category":"section"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"Writing in format 1 works the same as above, but you need different function values. Also you need to make sure the blocks are in the order gadget expects them to be!","category":"page"},{"location":"write_data/","page":"Writing Data","title":"Writing Data","text":"write_header(filename, header, snap_format=1)\nwrite_block(filename,  pos,    snap_format=1)\nwrite_block(filename,  vel,    snap_format=1)\nwrite_block(filename,  id,     snap_format=1)","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"read_data.md\", \n          \"write_data.md\",\n          \"api.md\"]\nDepth = 3","category":"page"},{"location":"read_data/#Read-Snapshot-Data","page":"Reading Data","title":"Read Snapshot Data","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"CurrentModule = GadgetIO\nDocTestSetup = quote\n    using GadgetIO\nend","category":"page"},{"location":"read_data/#Reading-the-header","page":"Reading Data","title":"Reading the header","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Reading the header block of the simulation can be done by using:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = read_header(filename::String)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Where h is the returned Header object:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"mutable struct Header\n    npart::Vector{Int32}                # an array of particle numbers per type in this snapshot\n    massarr::Vector{Float64}            # an array of particle masses per type in this snapshot - if zero: MASS block present\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    flag_sfr::Int32                     # 1 if simulation was run with star formation, else 0\n    flag_feedback::Int32                # 1 if simulation was run with stellar feedback, else 0\n    nall::Vector{UInt32}                # total number of particles in the simulation\n    flag_cooling::Int32                 # 1 if simulation was run with cooling, else 0\n    num_files::Int32                    # number of snapshots over which the simulation is distributed\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_stellarage::Int32              # 1 if simulation was run with stellar age, else 0\n    flag_metals::Int32                  # 1 if simulation was run with metals, else 0\n    npartTotalHighWord::Vector{UInt32}  # weird\n    flag_entropy_instead_u::Int32       # 1 if snapshot U field contains entropy instead of internal energy, else 0\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32                 # 1 if the IC file contains an INFO block   \n    lpt_scalingfactor::Float32          # (almost) never used\n    fill::Vector{Int32}                 # the HEAD block needs to be filled with zeros to have a size of 256 bytes\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This is equivalent to:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = head_to_obj(filename::String)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read the header information into a dictionary you can use:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":" h = head_to_dict(filename::String)","category":"page"},{"location":"read_data/#Reading-a-snapshot","page":"Reading Data","title":"Reading a snapshot","text":"","category":"section"},{"location":"read_data/#Full-snapshot","page":"Reading Data","title":"Full snapshot","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read a simulation snapshot into memory with GadgetIO.jl, it's as easy as this:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    data = read_snap(filename)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return a dictionary with the header information in data[\"Header\"] and the blocks sorted by particle type.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"As an example, this is how you would access the positions of the gas particles:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    data[\"Parttype0\"][\"POS\"]","category":"page"},{"location":"read_data/#Specific-blocks","page":"Reading Data","title":"Specific blocks","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Reading specific blocks only works with Format 2 at the moment.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you only want to read a specific block for a single particle type, e.g. positions of gas particles, you can use the function with a specified blockname and particle type like so:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    pos = read_snap(filename, \"POS\", 0)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an array of the datatype of your simulation, usually Float32.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If the snapshot has no info block this will fail unfortunately.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can still read the specific block by supplying a hand-constructed Info_Line object:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"mutable struct Info_Line\n    block_name::String              # name of the data block, e.g. \"POS\"\n    data_type::DataType             # datatype of the block, e.g. Float32 for single precision, Float64 for double\n    n_dim::Int32                    # number of dimensions of the block, usually 1 or 3\n    is_present::Vector{Int32}       # array of flags for which particle type this block is present,\n                                    # e.g. gas only:  [ 1, 0, 0, 0, 0, 0 ]\n                                    # e.g. gas + BHs: [ 1, 0, 0, 0, 0, 1 ]\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"and passing that to the function read_block_by_name:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    pos = read_block_by_name(filename, \"POS\", info=pos_info, parttype=0)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"where pos_info is an Info_Line object.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_snap is used mainly as a wrapper function to call read_block_by_name, in case you were wondering about the function name change.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"I will collect some example Info_Line objects in a later release to be able to read some common blocks even without an info block.","category":"page"},{"location":"read_data/#Getting-snapshot-infos","page":"Reading Data","title":"Getting snapshot infos","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you have a Format 2 snapshot and just want to know what blocks the snapshot contains you can use the function","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    print_blocks(filename)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"to get an output of all block names.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If your simulation contains an INFO block you can read the info lines into Info_Line object like so:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"    info = read_info(filename, verbose=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an Array of Info_Line objects. The optional keyword verbose additionally gives the same functionality as print_blocks and prints the names to the console.","category":"page"},{"location":"read_data/#Reading-particles-by-referenced-ID","page":"Reading Data","title":"Reading particles by referenced ID","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to select specific particles to read from an array if IDs you can do this with read_particles_by_id:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_by_id(snap_base::String, selected_ids::Array{<:Integer}, \n                     blocks::Array{String}; \n                     parttype::Integer=0, verbose::Bool=true,\n                     pos0::Array{<:Real}=[-1.234, -1.234, -1.234],\n                     r0::Real=0.0, use_keys::Bool=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"snap_base defines the target snapshot, or the snapshot directory, selected_ids contains the list of IDs of the particles you want to read and blocks containes the blocksnames of the blocks you want to read. If the simulation is too large to read the whole snapshot into memory you can give values for pos0 and r0 to read only a specific region with read_particles_in_volume. See Read Subvolumes for details on this.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return a dictionary with all requested blocks.","category":"page"},{"location":"read_data/#Read-Subvolumes","page":"Reading Data","title":"Read Subvolumes","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you only want to read a subvolume of the whole simulation you can do this in two ways. To get all particles within a subvolume of the simulation you can use the functions read_particles_in_box or read_particles_in_volume.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_in_box takes a box defined by a lower-left corner and an upper-right corner and reads all requested blocks and particles in that volume.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function read_particles_in_box( filename::String, blocks::Vector{String},\n                                corner_lowerleft,\n                                corner_upperright;\n                                parttype::Int=0,\n                                verbose::Bool=true,\n                                use_keys::Bool=true )\n\n            (...)\n\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can define an array of blocks you want to read, these will be read in parallel with simple multi-threading.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_in_volume is a simple wrapper around read_particles_in_box, where you can define a central position and a radius around it and it will construct the box containing that sphere for you and read all particles in it.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function read_particles_in_volume( filename::String, blocks::Vector{String},\n                                   center_pos::Vector{AbstractFloat},\n                                   radius::AbstractFloat;\n                                   parttype::Int=0,\n                                   verbose::Bool=true,\n                                   use_keys::Bool=true )\n\n            (...)\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"In both functions parttype defines the particle type to be read, as in the previous read functions and verbose gives console output.","category":"page"},{"location":"read_data/#Peano-Hilbert-key-based-reading","page":"Reading Data","title":"Peano-Hilbert key based reading","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"For large simulations Gadget distributes snapshots over multiple files. These files contain particles associated with specific Peano-Hilbert keys.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=true (which is the default case) it constructs the peano hilbert keys, selects the relevant files and reads the particles from these files into a dictionary. This is considerably faster than the brute-force attempt.","category":"page"},{"location":"read_data/#Brute-Force-Reading","page":"Reading Data","title":"Brute-Force Reading","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you call read_particles_in_box or read_particles_in_volume with the keyword argument use_keys=false it reads all particles over all distributed files which are contained in the requested subvolume. This takes quite a lot longer than the key based reading, but sometimes it's the only option.","category":"page"},{"location":"read_data/#Filename","page":"Reading Data","title":"Filename","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"With the snapshots being distributed over multiple filenames you need to be careful with that keyword. In this case filename refers to the base-name. Assuming you want to read snapshot 140, which is in the snapshot directory 140 the filename is","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"filename = \"path/to/your/snapshot/directories/snapdir_140/snap_140\"","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"GadgetIO will then automatically loop through the sub-snapshots which end in \".0\", \".1\", ... , \".N\".","category":"page"},{"location":"read_data/#Example","page":"Reading Data","title":"Example","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to, e.g. read positions, velocities, masses, density and hsml for all gas particles within the virial radius of the most massive halo of a simulation you can do this as follows.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Assuming pos_halo is the position of the center of mass of the halo and r_vir is its virial radius you read the data with","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"blocks = [\"POS\", \"VEL\", \"MASS\", \"RHO\", \"HSML\"]\n\ndata   = read_particles_in_volume(filename, blocks, pos_halo, r_vir,\n                                  parttype=0,\n                                  verbose=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return a dictionary with the blocks as keys and containing the arrays for the particles.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"data[\"POS\"]  # array of positions\ndata[\"RHO\"]  # array of densities\n(...)","category":"page"},{"location":"read_data/#Read-distributed-snapshotfiles","page":"Reading Data","title":"Read distributed snapshotfiles","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read in a simulation whose snapshots have been distributed over a number of sub-snapshots you can use read_blocks_over_all_files.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_blocks_over_all_files(snap_base::String, blocks::Array{String}, filter_function::Function; \n                                    N_to_read::Integer=-1, parttype::Integer=0)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will read the specified blocks for all particles that pass the filter_function. This can be useful if you don't know where the region you are interested in is located and don't have enough memory to read in all particles.","category":"page"},{"location":"read_data/#Filter-functions","page":"Reading Data","title":"Filter functions","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"The filter_function can be any function that takes a String input and returns an Array of Integers, or CartesianCoordinates. For example, if you want to filter all particles with a Mach number larger than 1:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function mach_gt_1(snap_file)\n    mach = read_snap(snap_file, \"MACH\", 0)\n    sel  = findall( mach .> 1.0 )\n    return sel\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Or if you want to trick the function into reading all particles after all:","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"function pass_all(snap_file)\n    h = read_header(snap_file)\n    return collect(1:h.npart[1])\nend","category":"page"},{"location":"read_data/#Read-Subfind-Data","page":"Reading Data","title":"Read Subfind Data","text":"","category":"section"},{"location":"read_data/#Reading-the-header-2","page":"Reading Data","title":"Reading the header","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"Similarly to the normal snapshot you can read the header of the subfind output into a SubfindHeader object","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"struct SubfindHeader\n    nhalos::Int32                       # number of halos in the output file\n    nsubhalos::Int32                    # number of subhalos in the output file\n    nfof::Int32                         # number of particles in the FoF\n    ngroups::Int32                      # number of large groups in the output file\n    time::Float64                       # time / scale factor of the simulation\n    z::Float64                          # redshift of the simulation\n    tothalos::UInt32                    # total number of halos over all output files\n    totsubhalos::UInt32                 # total number of subhalos over all output files\n    totfof::UInt32                      # total number of particles in the FoF\n    totgroups::UInt32                   # total number of large groups over all output files\n    num_colors::Int32                   # number of colors\n    boxsize::Float64                    # total size of the simulation box\n    omega_0::Float64                    # Omega matter\n    omega_l::Float64                    # Omega dark enery\n    h0::Float64                         # little h\n    flag_doubleprecision::Int32         # 1 if snapshot is in double precision, else 0\n    flag_ic_info::Int32\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"using","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"h = read_subfind_header(filename::String)","category":"page"},{"location":"read_data/#Reading-the-subfind-files","page":"Reading Data","title":"Reading the subfind files","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you compiled Gadget with WRITE_SUB_IN_SNAP_FORMAT you can read the subfind output like you would a normal snapshot, with any of the above methods. For convenience you can also use a helper function provided by GadgetIO. Since each of the blocks is only relevant for either halos, subhalos, Fof or large groups you don't need to define a particly type, aka halo type in this case.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"So in order to read the virial radius of the halos in a file you can simply use","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"R_vir = read_subfind(filename, \"RVIR\")","category":"page"},{"location":"read_data/#Filtered-read-in","page":"Reading Data","title":"Filtered read-in","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read specific halos from the subfind output you can use the function","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"filter_subfind(filebase::String, blockname::String, filter_function::Function, nfiles::Integer=1)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will return an array of HaloIDs ","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"struct HaloID\n    file::Int64\n    id::Int64\nend","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"You can use this to read specific files with read_subfind and select the array entry via the id field.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"The filter_function argument takes any function that takes one input argument and returns true if the requirement is fulfilled, or false if not.","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"So to find e.g. all halos with a virial mass largert than 10^15 M_odot you can use","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"find_mass_gt_1e15(M) = ( (M > 1.e15) ? true : false )\n\nfiltered_subfind = filter_subfind(filebase, \"MVIR\", find_mass_gt_1e15)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This will search all subfind files in the directory and check if they fulfill the filter. Since halos in subfind files are sorted by mass you can also supply a number of files to search with the argument nfiles. That way, if you are looking for a very massive halo you can constrian the reading and filtering to only the first N files to save time.","category":"page"},{"location":"read_data/#Reading-particles-in-a-halo","page":"Reading Data","title":"Reading particles in a halo","text":"","category":"section"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"If you want to read all particles associated with a FoF halo you can do this with the function read_particles_in_halo","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"read_particles_in_halo( snap_base::String, blocks::Array{String},\n                        sub_base::String, halo::HaloID; \n                        rad_scale::Real=1.0, halo_type::Integer=1,\n                        parttype::Integer=0, verbose::Bool=true)","category":"page"},{"location":"read_data/","page":"Reading Data","title":"Reading Data","text":"This reads all blocks defined in blocks for the halo into a dictionary. snap_base and sub_base should point to the snap and subfind directories, or the files if you only have one file. The HaloID point to the selected halo. halo_type should be set to 1 for halos and 2 for subhalos.  If you didn't get all the particles you were looking for it might be that the search radius for the read-in was too small. rad_scale defines the multiplication factor for the search radius. For halos the default search radius is r_200 and for subhalos it's the half-mass radius.","category":"page"}]
}
